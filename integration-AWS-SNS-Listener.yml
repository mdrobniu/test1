category: Messaging and Conferencing
commonfields:
  id: AWS-SNS-Listener
  version: -1
configuration:
- advanced: true
  defaultvalue: "true"
  display: Long running instance
  hidden: true
  name: longRunning
  required: false
  section: Connect
  type: 8
- additionalinfo: Uses basic authentication for accessing the list. If empty, no authentication
    is enforced. (For Cortex XSOAR 8 and Cortex XSIAM) Optional for engines, otherwise
    mandatory.
  display: Username
  name: credentials
  required: false
  section: Connect
  type: 9
- additionalinfo: 'Set the endpoint of your listener. example: /snsv2'
  display: Endpoint
  name: endpoint
  required: false
  section: Connect
  type: 0
- additionalinfo: (For Cortex XSOAR 6.x) For use with HTTPS - the certificate that
    the service should use. (For Cortex XSOAR 8 and Cortex XSIAM) Custom certificates
    are not supported.
  display: Certificate (Required for HTTPS)
  name: certificate
  required: false
  section: Connect
  type: 12
- additionalinfo: (For Cortex XSOAR 6.x) For use with HTTPS - the private key that
    the service should use. (For Cortex XSOAR 8 and Cortex XSIAM) When using an engine,
    configure a private API key. Not supported on the Cortex XSOAR​​ or Cortex XSIAM
    server.
  display: Private Key (Required for HTTPS)
  name: key
  required: false
  section: Connect
  type: 14
- additionalinfo: Because this is a push-based integration, it cannot fetch sample
    events in the mapping wizard. After you finish mapping, it is recommended to turn
    off the sample events storage to reduce performance overhead.
  display: Store sample events for mapping
  name: store_samples
  required: false
  section: Connect
  type: 8
- advanced: true
  display: Use system proxy settings
  name: proxy
  required: false
  section: Connect
  type: 8
- additionalinfo: 'Runs the service on this port from within Cortex XSOAR. Requires
    a unique port for each long-running integration instance. Do not use the same
    port for multiple instances. Note: If you click the **Test** button more than
    once, a failure may occur mistakenly indicating that the port is already in use.'
  display: Listen Port
  name: longRunningPort
  required: true
  section: Connect
  type: 0
- display: Incident type
  name: incidentType
  required: false
  type: 13
contentitemexportablefields:
  contentitemfields:
    definitionid: ""
    fromServerVersion: 6.10.0
    itemVersion: 1.0.10
    packID: AWS-SNS-Listener
    packName: AWS-SNS-Listener
    packPropagationLabels:
    - all
    prevname: ""
    propagationLabels: []
    toServerVersion: ""
description: Amazon Simple Notification Service (SNS) is a managed service that provides
  message delivery from publishers to subscribers.
detaileddescription: "## AWS-SNS-Listener Help\n\nIn order to configure the AWS-SNS-Listener\n\nXSOAR6\n\n*
  http: configure an endpoint and a free port for the internal long running server.\n*
  https: In addition to http configuration please add a CA certificate and private\n*
  key AWS-SNS works only with CA certificates.\n* Another option is via engine. \n
  \  \nConfiguring the subscriber on AWS-SNS UI is straightforward:\n```http/https://<instance-name_or_IP>:<port>/<endpoint_configured>```\nFor
  more general information on long running integrations on XSOAR6:\n[XSOAR6 Long Running](https://xsoar.pan.dev/docs/reference/articles/long-running-invoke)\n\nXSOAR8
  or XSIAM:\n\n* The instance should be configured to run only on HTTP. \n* The instance
  is using the HTTPS certificate of the server.\n* Please set a user and password
  (can be global via long running integrations configurations)\n* or local for this
  integration only.\n   \nConfiguring the subscriber on AWS-SNS UI:\n```https://<username:password>@ext-<cortex-xsoar-address>/xsoar/instance/execute/<instance-name>```\n\nexample:\n```https://user:pass@ext-myxsoar-address/xsoar/instance/execute/My-AWS-SNS-Listener/sns_ep```\n\nFor
  more info on long running integrations on XSOAR8 or XSIAM:\n[XSOAR8 or XSIAM Long
  Running](https://docs-cortex.paloaltonetworks.com/r/Cortex-XSOAR/8/Cortex-XSOAR-Administrator-Guide/Forward-Requests-to-Long-Running-Integrations)\n\n---\n[View
  Integration Documentation](https://xsoar.pan.dev/docs/reference/integrations/aws-sns-listener)"
display: AWS-SNS-Listener
image: data:image/png;base64,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
name: AWS-SNS-Listener
script:
  dockerimage: demisto/fastapi:0.115.12.3243695
  isFetchSamples: true
  longRunning: true
  longRunningPort: true
  runonce: false
  script: |
    register_module_line('AWS-SNS-Listener', 'start', __line__())
    CONSTANT_PACK_VERSION = '1.0.10'
    demisto.debug('pack id = AWS-SNS-Listener, pack version = 1.0.10')
    import base64
    from collections import deque
    from secrets import compare_digest
    from tempfile import NamedTemporaryFile
    from traceback import format_exc

    import uvicorn

    from fastapi import Depends, FastAPI, Request, Response, status
    from fastapi.openapi.models import APIKey
    from fastapi.security import HTTPBasic, HTTPBasicCredentials
    from fastapi.security.api_key import APIKeyHeader
    from M2Crypto import X509



    PARAMS: dict = demisto.params()
    sample_events_to_store = deque(maxlen=20)  # type: ignore[var-annotated]

    app = FastAPI(docs_url=None, redoc_url=None, openapi_url=None)
    basic_auth = HTTPBasic(auto_error=False)
    token_auth = APIKeyHeader(auto_error=False, name="Authorization")

    PROXIES, USE_SSL = handle_proxy_for_long_running()


    class AWS_SNS_CLIENT(BaseClient):  # pragma: no cover
        def __init__(self, base_url=None):
            if PROXIES:
                self.proxies = PROXIES
            elif PARAMS.get("proxy"):
                self.proxies = handle_proxy()
            headers = {"Accept": "application/json"}
            super().__init__(base_url=base_url, proxy=bool(PROXIES), verify=USE_SSL, headers=headers)

        def get(self, full_url, resp_type="json"):
            return self._http_request(method="GET", full_url=full_url, proxies=PROXIES, resp_type=resp_type)


    client = AWS_SNS_CLIENT()


    class ServerConfig:  # pragma: no cover
        def __init__(self, certificate_path, private_key_path, log_config, ssl_args):
            self.certificate_path = certificate_path
            self.private_key_path = private_key_path
            self.log_config = log_config
            self.ssl_args = ssl_args


    class SNSCertificateManager:
        def __init__(self):
            self.cached_cert_url = None

        def is_valid_sns_message(self, sns_payload):
            """
            Validates an incoming Amazon Simple Notification Service (SNS) message.

            Args:
                sns_payload (dict): The SNS payload containing relevant fields.

            Returns:
                bool: True if the message is valid, False otherwise.
            """
            # taken from https://github.com/boto/boto3/issues/2508
            demisto.debug("In is_valid_sns_message")
            # Can only be one of these types.
            if sns_payload["Type"] not in ["SubscriptionConfirmation", "Notification", "UnsubscribeConfirmation"]:
                demisto.error("Not a valid SNS message")
                return False

            # Amazon SNS currently supports signature version 1 or 2.
            if sns_payload.get("SignatureVersion") not in ["1", "2"]:
                demisto.error("Not using the supported AWS-SNS SignatureVersion 1 or 2")
                return False
            demisto.debug(f'Handling Signature Version: {sns_payload.get("SignatureVersion")}')
            # Fields for a standard notification.
            fields = ["Message", "MessageId", "Subject", "Timestamp", "TopicArn", "Type"]

            # Determine the required fields based on message type
            if sns_payload["Type"] in ["SubscriptionConfirmation", "UnsubscribeConfirmation"]:
                fields = ["Message", "MessageId", "SubscribeURL", "Timestamp", "Token", "TopicArn", "Type"]

            # Build the string to be signed.
            string_to_sign = ""
            for field in fields:
                string_to_sign += field + "\n" + sns_payload[field] + "\n"

            # Verify the signature
            decoded_signature = base64.b64decode(sns_payload["Signature"])
            if sns_payload["SigningCertURL"] == self.cached_cert_url:
                demisto.debug(f'Current SigningCertURL: {sns_payload["SigningCertURL"]} was verified already.')
                return True
            try:
                demisto.debug(f'sns_payload["SigningCertURL"] = {sns_payload["SigningCertURL"]}')
                response: requests.models.Response = client.get(full_url=sns_payload["SigningCertURL"], resp_type="response")
                response.raise_for_status()
                certificate = X509.load_cert_string(response.text)
            except Exception as e:
                demisto.error(f"Exception validating sign cert url: {e}")
                if "502" in str(e):
                    demisto.error(f'SigningCertURL: {sns_payload["SigningCertURL"]}')
                elif "Verify that the server URL parameter" in str(e):
                    demisto.error(f"client base url: {client._base_url}")
                elif "Proxy Error" in str(e):
                    demisto.error(f"PROXIES = {PROXIES}")
                demisto.debug("SigningCertURL failed. Deleting the saved SigningCertURL.")
                self.cached_cert_url = None
                return False

            public_key = certificate.get_pubkey()
            # Verify the signature based on SignatureVersion
            if sns_payload["SignatureVersion"] == "1":
                public_key.reset_context(md="sha1")
            else:  # version2
                public_key.reset_context(md="sha256")

            public_key.verify_init()
            public_key.verify_update(string_to_sign.encode())
            verification_result = public_key.verify_final(decoded_signature)

            if verification_result != 1:
                demisto.debug("SigningCertURL failed. Deleting the saved SigningCertURL.")
                self.cached_cert_url = None
                return False

            demisto.debug("Signature verification succeeded.")
            self.cached_cert_url = sns_payload["SigningCertURL"]
            return True


    sns_cert_manager = SNSCertificateManager()


    def is_valid_integration_credentials(credentials, request_headers, token):
        credentials_param = PARAMS.get("credentials")
        auth_failed = False
        header_name = None
        if credentials_param and (username := credentials_param.get("identifier")):
            password = credentials_param.get("password", "")
            if username.startswith("_header"):
                header_name = username.split(":")[1]
                token_auth.model.name = header_name
                if not token or not compare_digest(token, password):
                    auth_failed = True
            elif (not credentials) or (
                not (compare_digest(credentials.username, username) and compare_digest(credentials.password, password))
            ):
                auth_failed = True
            if auth_failed:
                secret_header = (header_name or "Authorization").lower()
                if secret_header in request_headers:
                    request_headers[secret_header] = "***"
                demisto.debug(f"Authorization failed - request headers {request_headers}")
        if auth_failed:  # auth failed not valid credentials
            return False, header_name
        else:
            return True, header_name


    def handle_subscription_confirmation(subscribe_url) -> requests.Response:  # pragma: no cover
        demisto.debug("SubscriptionConfirmation request")
        response: requests.models.Response = client.get(full_url=subscribe_url, resp_type="response")
        response.raise_for_status()
        return response


    def handle_notification(payload, raw_json):
        message = payload["Message"]
        demisto.debug(f"Notification request msg: {message}")
        return {
            "name": payload["Subject"],
            "labels": [],
            "rawJSON": raw_json,
            "occurred": payload["Timestamp"],
            "details": f'ExternalID:{payload["MessageId"]} TopicArn:{payload["TopicArn"]} Message:{message}',
            "type": "AWS-SNS Notification",
        }


    def store_samples(incident):  # pragma: no cover
        try:
            sample_events_to_store.append(incident)
            integration_context = get_integration_context()
            sample_events = deque(json.loads(integration_context.get("sample_events", "[]")), maxlen=20)
            sample_events += sample_events_to_store
            integration_context["sample_events"] = list(sample_events)
            set_to_integration_context_with_retries(integration_context)
        except Exception as e:
            demisto.error(f"Failed storing sample events - {e}")


    @app.post(f'/{PARAMS.get("endpoint","")}')
    async def handle_post(
        request: Request, credentials: HTTPBasicCredentials = Depends(basic_auth), token: APIKey = Depends(token_auth)
    ):  # pragma: no cover
        """
        Handles incoming AWS-SNS POST requests.
        Supports SubscriptionConfirmation, Notification and UnsubscribeConfirmation.

        Args:
            request (Request): The incoming HTTP request.
            credentials (HTTPBasicCredentials): Basic authentication credentials.
            token (APIKey): API key for authentication.

        Returns:
            Union[Response, str]: Response data or error message.
        """
        data = ""
        request_headers = dict(request.headers)
        is_valid_credentials = False
        try:
            is_valid_credentials, header_name = is_valid_integration_credentials(credentials, request_headers, token)
        except Exception as e:
            demisto.error(f"Error handling auth failure: {e}")
        if not is_valid_credentials:
            return Response(status_code=status.HTTP_401_UNAUTHORIZED, content="Authorization failed.")

        secret_header = (header_name or "Authorization").lower()
        request_headers.pop(secret_header, None)

        try:
            type = request_headers["x-amz-sns-message-type"]
            payload = await request.json()
            raw_json = json.dumps(payload)
        except Exception as e:
            demisto.error(f"Error in request parsing: {e}")
            return Response(status_code=status.HTTP_400_BAD_REQUEST, content="Failed parsing request.")
        if not sns_cert_manager.is_valid_sns_message(payload):
            return Response(status_code=status.HTTP_401_UNAUTHORIZED, content="Validation of SNS message failed.")

        if type == "SubscriptionConfirmation":
            demisto.debug("SubscriptionConfirmation request")
            subscribe_url = payload["SubscribeURL"]
            try:
                response = handle_subscription_confirmation(subscribe_url=subscribe_url)
            except Exception as e:
                demisto.error(f"Failed handling SubscriptionConfirmation: {e}")
                return "Failed handling SubscriptionConfirmation"
            demisto.debug(f"Response from subscribe url: {response}")
            return response
        elif type == "Notification":
            incident = handle_notification(payload, raw_json)
            data = demisto.createIncidents(incidents=[incident])
            demisto.debug(f"Created incident: {incident}")
            if PARAMS.get("store_samples"):
                store_samples(incident)
            if not data:
                demisto.error("Failed creating incident")
                data = "Failed creating incident"
            return data
        elif type == "UnsubscribeConfirmation":
            message = payload["Message"]
            demisto.debug(f"UnsubscribeConfirmation request msg: {message}")
            return f"UnsubscribeConfirmation request msg: {message}"
        else:
            demisto.error(f'Failed handling AWS SNS request, unknown type: {payload["Type"]}')
            return f'Failed handling AWS SNS request, unknown type: {payload["Type"]}'


    def unlink_certificate(certificate_path, private_key_path):  # pragma: no cover
        if certificate_path:
            os.unlink(certificate_path)
        if private_key_path:
            os.unlink(private_key_path)
        time.sleep(5)


    def setup_server():  # pragma: no cover
        certificate = PARAMS.get("certificate", "")
        private_key = PARAMS.get("key", "")

        certificate_path = ""
        private_key_path = ""
        ssl_args = {}
        if certificate and private_key:
            certificate_file = NamedTemporaryFile(delete=False)
            certificate_path = certificate_file.name
            certificate_file.write(bytes(certificate, "utf-8"))
            certificate_file.close()
            ssl_args["ssl_certfile"] = certificate_path

            private_key_file = NamedTemporaryFile(delete=False)
            private_key_path = private_key_file.name
            private_key_file.write(bytes(private_key, "utf-8"))
            private_key_file.close()
            ssl_args["ssl_keyfile"] = private_key_path

            demisto.debug("Starting HTTPS Server")
        else:
            demisto.debug("Starting HTTP Server")

        integration_logger = IntegrationLogger()
        integration_logger.buffering = False
        log_config = dict(uvicorn.config.LOGGING_CONFIG)
        log_config["handlers"]["default"]["stream"] = integration_logger
        log_config["handlers"]["access"]["stream"] = integration_logger
        return ServerConfig(
            log_config=log_config, ssl_args=ssl_args, certificate_path=certificate_path, private_key_path=private_key_path
        )


    def test_module():  # pragma: no cover
        """
        Assigns a temporary port for longRunningPort and returns 'ok'.
        """
        if not PARAMS.get("longRunningPort"):
            PARAMS["longRunningPort"] = "1111"
        return "ok"


    """ MAIN FUNCTION """


    def main():  # pragma: no cover
        demisto.debug(f"Command being called is {demisto.command()}")
        try:
            if demisto.command() == "test-module":
                return return_results(test_module())
            try:
                port = int(demisto.params().get("longRunningPort"))
            except ValueError as e:
                raise ValueError(f"Invalid listen port - {e}")
            if demisto.command() == "long-running-execution":
                demisto.debug("Started long-running-execution.")
                while True:
                    server_config = setup_server()
                    if not server_config:
                        raise DemistoException("Failed to configure server.")
                    try:
                        uvicorn.run(
                            app,
                            host="0.0.0.0",
                            port=port,
                            log_config=server_config.log_config,  # type: ignore[arg-type]
                            **server_config.ssl_args,
                        )
                    except Exception as e:
                        demisto.error(f"An error occurred in the long running loop: {e!s} - {format_exc()}")
                        demisto.updateModuleHealth(f"An error occurred: {e!s}")
                    finally:
                        unlink_certificate(server_config.certificate_path, server_config.private_key_path)
            else:
                raise NotImplementedError(f"Command {demisto.command()} is not implemented.")
        except Exception as e:
            demisto.error(format_exc())
            return_error(f"Failed to execute {demisto.command()} command. Error: {e}")


    if __name__ in ("__main__", "__builtin__", "builtins"):
        main()

    register_module_line('AWS-SNS-Listener', 'end', __line__())
  subtype: python3
  type: python
system: true
