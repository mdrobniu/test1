category: Email
commonfields:
  id: EWS v2
  version: -1
configuration:
- display: Email address
  name: credentials
  required: true
  section: Connect
  type: 9
- additionalinfo: Mailbox to run commands on and to fetch incidents from.
  display: Email address from which to fetch incidents
  name: defaultTargetMailbox
  required: true
  section: Collect
  type: 0
- defaultvalue: Inbox
  display: Name of the folder from which to fetch incidents (supports Exchange Folder
    ID and sub-folders e.g. Inbox/Phishing)
  name: folder
  required: true
  section: Collect
  type: 0
- advanced: true
  defaultvalue: "false"
  display: Public Folder
  name: isPublicFolder
  required: false
  section: Connect
  type: 8
- advanced: true
  defaultvalue: "false"
  display: Has impersonation rights
  name: impersonation
  required: false
  section: Connect
  type: 8
- advanced: true
  defaultvalue: "false"
  display: Use system proxy settings
  name: proxy
  required: false
  section: Connect
  type: 8
- display: Fetch incidents
  name: isFetch
  required: false
  section: Collect
  type: 8
- defaultvalue: 10 minutes
  display: First fetch timestamp (<number> <time unit>, e.g., 12 hours, 7 days)
  name: fetch_time
  required: false
  section: Collect
  type: 0
- advanced: true
  display: Mark fetched emails as read
  name: markAsRead
  required: false
  section: Collect
  type: 8
- display: Incident type
  name: incidentType
  required: false
  section: Connect
  type: 13
- advanced: true
  display: |-
    ┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉
    ‎                                           Manual Mode
    Exchange Server Hostname or IP address
  name: ewsServer
  required: false
  section: Connect
  type: 0
- advanced: true
  display: DOMAIN\USERNAME (e.g. DEMISTO.INT\admin)
  name: domainAndUserman
  required: false
  section: Connect
  type: 0
- advanced: true
  display: 'Exchange Server Version (On-Premise only. Supported versions: 2007, 2010,
    2010_SP2, 2013, 2013_SP1, 2016, and 2019)'
  name: defaultServerVersion
  required: false
  section: Connect
  type: 0
- advanced: true
  display: Trust any certificate (not secure)
  name: insecure
  required: false
  section: Connect
  type: 8
- advanced: true
  display: |-
    ┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉┉
    ‎                                         Advanced Mode
    Override Authentication Type (NTLM, Basic, or Digest).
  name: authType
  required: false
  section: Connect
  type: 0
- advanced: true
  defaultvalue: "120"
  display: Timeout (in seconds) for HTTP requests to Exchange Server
  name: requestTimeout
  required: false
  section: Connect
  type: 0
- defaultvalue: "50"
  display: Max incidents per fetch
  name: maxFetch
  required: false
  section: Collect
  type: 0
- advanced: true
  defaultvalue: "true"
  display: Run as a separate process (protects against memory depletion)
  name: separate_process
  required: false
  section: Connect
  type: 8
- advanced: true
  defaultvalue: "false"
  display: Use legacy attachment name
  name: legacy_name
  required: false
  section: Collect
  type: 8
- advanced: true
  display: Skip unparsable emails during fetch incidents
  name: skip_unparsable_emails
  required: false
  section: Collect
  type: 8
- defaultvalue: "1"
  display: Incidents Fetch Interval
  name: incidentFetchInterval
  required: false
  type: 19
contentitemexportablefields:
  contentitemfields:
    definitionid: ""
    fromServerVersion: 5.0.0
    itemVersion: 2.2.6
    packID: MicrosoftExchangeOnPremise
    packName: Microsoft Exchange On-Premise
    packPropagationLabels:
    - all
    prevname: ""
    propagationLabels: []
    toServerVersion: ""
defaultclassifier: EWS v2
defaultmapperin: EWS v2-mapper
description: Exchange Web Services and Office 365 (mail).
detaileddescription: '[View Integration Documentation](https://xsoar.pan.dev/docs/reference/integrations/ews-v2)'
display: EWS v2
image: data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHgAAAAyCAYAAACXpx/YAAAAAXNSR0IArs4c6QAADIVJREFUeAHtXHt0FNUZv/fOYzebJ3k1CQ8THiaBBLAEiuIRAu2hoqinSrR6xIqeoq1gRast2rr8UThYPT5QKigeDvScUkCl1lePWiggL4MYFWMMLxMgaTYk2WR3Z+dx7+13JxGBJmQ3BJgN+U4mMztzHzPf737f/b7vfjMYXQLEEcJos1ea21SWUdUSzg1o+PKcZNeiIQr62Uu3jfy0L7NA7ksPZwM5BUmPPeSLqzrRMPh4IDysNmiMzOB0tL6djKC8ZRjjPJViBVWeCKH7ipNpX3r+zp4lZgEGMAniXJr28s7MFtM1tMGkBUMYv0K3+KhARVUuZySLEqJSJEExghADLDmDDWoiHbkUAj/6PjkeYFsqvUiae3lVylet5sCmkJ7fRq3R2RYr1hbvHGoYbBDF4RQmKYhxDEACbgz2Akza5wW02xHqKICFVK6tqI/72z5fVnMofHlDiBRkWdaoMLVGWQdP5FFK0ylRJQpTajuIUEMIpACV6t0+7KVYwDEAZyz5+Pl0JuVbbx8YYZhYqFdPu3oVYIKKtdUrHFPjUsSpx8/sGIBPGMp8G0RbvYJYUgseSmz9dC4ccAzAyOpXsecCZFd1Qff1U1/mgHMk+CJyGSYEmNzB7eoFElZCLzTTa030AwysnLyi/OffhMhcFu65AUdgjGAiaWNUa/1n/vdXY6/XEX52HwIYZEfIYfu/dqs7Qjlo0HFug4avQYbwuXpKoi5HfpNMn5o1swUh7xs9bak368UQwICerNr4EQzH4DYRsQNrW+wwYjpIURh+BCBaxUyGIbAVIWAYGrN96W6sdtyFFrf7ae8rbCKUlpSyGkDqBzjykYqRR0XNOfFog85oYxxRmjjiTUR1t0im0ZzgSWpNdfMADVttlw0YEPq2pWn81nrrA93sBrCOG4jjKKQS1GxJ0gDWWfQLgJUFtpw3wQA6Y9TACYaSKIcAt7gEYDMuJ0b+bOe3ZGxIMCEoXiGHqhZMeACkFWTk7PST5XtMGABnL3TK1fEu9Gp6Bt54pF564ts26X7LFF101AdwVRlrYzKUB5BO35FMelrDASiZlOC6fo/PXGWZHfaVCMo4hGIDYGAWhdUDWPLjqNTbLessiiMT3Y6WVs4tCcFhiM9C8/LG7/LVIemPZof0KyC6eUl83u77x7/WVcelK8r3d6G8u6pywc7HDMBncsTr9ZKjRTcXyUx1n3mtJqgV86ZuBf1ktVXbfYl+PZyEpg0+fnjDxEVjn9+buL8FP4RBegtT2Cv75l+5GjQHWry1OkOicS5RkWqavnDGCJ/dCOhke+/Af469se54lTrhjoSVn/ve9VtkIFhapxSHORHmQdOKXE2+9kXNvZUh6cmnl2xf+eLU3KUN/67N58SFBrv0TxYWJy2Axjm4UvOf2dn0OKXMDf4QSnPxCl6+YhoumRv5SDrlLi/UYcwCHAoQ3GoyosFsa8ewz4FjPoO7WkJWssyk387/T81Mn44KXFhvGJul3jWrdFSwdOW++Xsa9Gd1g4rRY4dEMOcp59DlBavq1KkjIgaAW3SawRNRpU4KSQAb/CHLstDxAC8gkoRyEvnCN2ePq5wM4O4W4OoWFBFaQXTJERauVQxQzEpwWGkVmLgRLPTDemI7q2kHAOfAe0xklC7TD6sXXLVmwrJdd++pDz1jmCKT4IyxxL+fd1VFMTF3pqaOWYCTTE0fkqxuqg/hzKBuIsqYlJWgZPtNKzWg4yFiHo6eMHJJNDxjROLDE5fvufWLRrbCsCDnxw6sfN8egUGV5eZfo7fr7Mm/uiU01U5CiL7D814jZgFeUHaVBiy/FzgkDNx27r87T82vuqMsRPEaakYeV6aMSzanJRllx7F/VjUG8z73sVcNisBL4m2AsGZgNZNbIKXgkw+KY7tfmzl8Dhrh5WNe2DXnqya+CLJNzjtYPekgpudgoTdhs1ME7OMZy3S/haPmdKab1Kki7gkg1Qf5tPJ66+865eAOcZQaLx+bOyZj+tB4ssyjyiYCFd4YZtnz3jv446v/su/2b/x8BWgPiKF+L+E9AeJ81YlpgDtjCqMsqiCHaGNb6sE1RSn4adWlIM3iqTpFLtuggrm8McgLNh3wP7t8Suofpg2Mn5Kqsu0aUoZ82Wy9vrc+tAYsa/lcrfjOnqO3zsWsivau369WmujGD462tRimruclxKHBKW50rNUobhER/yjocVdh+p4hrz9ZYFznO8KUpeYp6p2BZV0bIlNmf/Tfd2bnqdf9YbQ89fZtaFFNK3/U4BhUu7ON6ZgFGCmG56MD2gpYnhuAwaCt8luoujUImpKBpo2O6Zvr9DlDtRsmX53tfkTmAfJ1q7SYU/B5Yb71SJyGTZM06OqkVdXGO1/V6DdVPVL6+I9e3Lujus1c4ddJDqLRDagoxt45F41ZFe02k7hBuQZAQE47Ax+WIgPix0YUEazvuNdiIFajSdPXVzXt+DZoXI+gLQxLkyky33/zsJQ5qkJMbupiuWnSNt21acYLW9P3PDDu7Ruz5GlZHrxTlHUqxSzAvc5QSMeFxaDEkEUmcVnBCTKtunek/NNtxwMFBpJsBLlloDYAeWeb/OaUlzZnrb675Os7c6VrM1T6vvCfnUgxC7AIdBDMPUgBY1dIkAh4EJgSIU58MqsjWo4L3xl83niJVhV76Iwqf2JSncYeZPbyYXtjNshUmXSo1f0KX79eWlpW4i9KUv+ktDta0fZ43ss7c9hF8NgjTTU0PJktqWzS0xNceHDAYImShDMYJymMsR+AnZUctesCUpiisNpJGcrNb6X8+ejwmoe36EzynGlIcZhzgwrPQ0ObxWiiTBHpIM50k2IW4LKyUSKS8ZQYC7DoDk4sbLNm4S1PrVdu+evOe3RZflFIW0Qk4BHgqqz2mgz3DZt+ecX+0c+VP1ar8StVrGscQt7gAMed6g5BcOSkv82pCHU5k2JLRfu8nYqJHeQQAY8NG2hpHg6fCJhtsBwQMcddYIZnqbz+6kzP9QDuZzNe/fSaA23WkyLhqyQr7jeFae5b4t2K3wV6WIUEAFWWkCdG3k6MIQnG0sejfR7unaUh7xYRverSF5JkFtUy08RsZXVynLJ26cxRNfetqcjceDS4SqdSnEeix2/KSXjjkZn5jbPXVU5o0klKyIQwh6IgjxFuQyVzow6qRDzqeqlgbAAM7/b6NVJ47YbqClVZ7CNL0LFsjGrcRD6a4SE+i9PaAYpSn+NJavzduGEtEzZuJ1oUDHq5bOwxURwWKNx5T+9e3WxKw8VLbmEk5yz5vHHdnWsqbl9zW+E3Zzb5nY4gWMzBzqTYABh4BzlZStAkeUGM89qtZUg0h/NHdYYwDAAMKwES0VrfONLQoBCcEDaMiM0eYQ2vHDAuYeyyT547HibX8o73pBik5LZgddpH9eF/3bq6/JZ1d42r6QzG6as+TT+LQumsygU7FzMA2xwR67xiFhZv6wOJw5OWDsIK5EKnAeppYBXBLnKhmuwf/ouKw/4nQpqVe+aqkDDU6oPy2LeOmDtSF+9s/H8gCSRbsgwT8gFOku2qnfx1UQ9iC+CzsgrgFn6sQB2oY9f+o5v/9SGW2WaS3C6/CADrFzommbrOM9v97FMbFH0CuN8lGQiDmrK2U0tczOM+BHDP2QivNUBlcCgikbyuEglEXdhUt4p8geCven43vVuzH2Dg52XxUpOGpIMUXn7pKREYIEGLN+bFm//Yer+2DjsE4n6AAdEP7/nhqjpUtzYbZUej2U8bC3V1CGevLDXwwi0WfvC0Sxf1Rz/AwH6M7TchHO/T9mSk9Fwn9aS3/joXnAOOkWAMq0K2/XLaB8t6rDEvOCOd2qFjAIZVnF+7JFwEHzMrChg8lzL4lBKWFWp/0A6APg14p7LTefflGIBP/H7icoARI/jW5KJHqz2fHDeHHNNCw5tCKD9IaTFHpChM8SDOWJoFr+LaAQ57lQ6OmJD0fmnvbHg5BmBxcyJcgLbAx7G2jGiFn192bAI6jMrL5bsPpaXVBAJDj7Vp+ZCdM7rVRPmagYZZBA2E96/jYRBASBNqnZT2yKNZUKtPkqMA7orDNvAlJSKzrb5j2yHKApZk0ebD6vbDjTmBsJTfEDALwpwXBy1WCEDnQfgwnRFZYvYHSQFskVF7iUl7TAAswOyMAHiGSvPCcO1Qx/aeLe3w8dKFoyuTdzXQQbUBbYRu0TGgEgogEaOQUTzYQiRJUmBB11Khib5NMQ1wZ9DY0u4V30AsPAHXxVYB20Yh7WCmS2Vr92YfaFVzMzx8wqB4ubmzNvrSuf8BON13AZrf558AAAAASUVORK5CYII=
name: EWS v2
script:
  commands:
  - arguments:
    - description: The ID of the email message for which to get the attachments.
      name: item-id
      required: true
    - description: The mailbox in which this attachment was found. If empty, the default
        mailbox is used. Otherwise the user might require impersonation rights to
        this mailbox.
      name: target-mailbox
    - description: The attachments ids to get. If none - all attachments will be retrieve
        from the message. Support multiple attachments with comma-separated value
        or array.
      isArray: true
      name: attachment-ids
    description: Retrieves the actual attachments from an item (email message). To
      get all attachments for a message, only specify the item-id argument.
    name: ews-get-attachment
    outputs:
    - contextPath: EWS.Items.FileAttachments.attachmentId
      description: The attachment ID. Used for file attachments only.
      type: string
    - contextPath: EWS.Items.FileAttachments.attachmentName
      description: The attachment name. Used for file attachments only.
      type: string
    - contextPath: EWS.Items.FileAttachments.attachmentSHA256
      description: The SHA256 hash of the attached file.
      type: string
    - contextPath: EWS.Items.FileAttachments.attachmentLastModifiedTime
      description: The attachment last modified time. Used for file attachments only.
      type: date
    - contextPath: EWS.Items.ItemAttachments.datetimeCreated
      description: The created time of the attached email.
      type: date
    - contextPath: EWS.Items.ItemAttachments.datetimeReceived
      description: The received time of the attached email.
      type: date
    - contextPath: EWS.Items.ItemAttachments.datetimeSent
      description: The sent time of the attached email.
      type: date
    - contextPath: EWS.Items.ItemAttachments.receivedBy
      description: The received by address of the attached email.
      type: string
    - contextPath: EWS.Items.ItemAttachments.subject
      description: The subject of the attached email.
      type: string
    - contextPath: EWS.Items.ItemAttachments.textBody
      description: The body of the attached email (as text).
      type: string
    - contextPath: EWS.Items.ItemAttachments.headers
      description: The headers of the attached email.
      type: Unknown
    - contextPath: EWS.Items.ItemAttachments.hasAttachments
      description: Whether the attached email has attachments.
      type: boolean
    - contextPath: EWS.Items.ItemAttachments.itemId
      description: The attached email item ID.
      type: string
    - contextPath: EWS.Items.ItemAttachments.toRecipients
      description: A list of recipient email addresses for the attached email.
      type: Unknown
    - contextPath: EWS.Items.ItemAttachments.body
      description: The body of the attached email (as HTML).
      type: string
    - contextPath: EWS.Items.ItemAttachments.attachmentSHA256
      description: The SHA256 hash of the attached email (as EML file).
      type: string
    - contextPath: EWS.Items.ItemAttachments.FileAttachments.attachmentSHA256
      description: SHA256 hash of the attached files inside of the attached email.
      type: string
    - contextPath: EWS.Items.ItemAttachments.ItemAttachments.attachmentSHA256
      description: SHA256 hash of the attached emails inside of the attached email.
      type: string
    - contextPath: EWS.Items.ItemAttachments.isRead
      description: The read status of the attachment.
      type: String
  - arguments:
    - description: The ID of the email message for which to delete attachments.
      name: item-id
      required: true
    - description: The mailbox in which this attachment was found. If empty, the default
        mailbox is used. Otherwise the user might require impersonation rights to
        this mailbox.
      name: target-mailbox
    - description: A CSV list (or array) of attachment IDs to delete. If empty, all
        attachments will be deleted from the message.
      isArray: true
      name: attachment-ids
    description: Deletes the attachments of an item (email message).
    name: ews-delete-attachment
    outputs:
    - contextPath: EWS.Items.FileAttachments.attachmentId
      description: The ID of the deleted attachment, in case of file attachment.
      type: string
    - contextPath: EWS.Items.ItemAttachments.attachmentId
      description: The ID of the deleted attachment, in case of other attachment (for
        example, "email").
      type: string
    - contextPath: EWS.Items.FileAttachments.action
      description: 'The deletion action in case of file attachment. This is a constant
        value: ''deleted''.'
      type: string
    - contextPath: EWS.Items.ItemAttachments.action
      description: 'The deletion action in case of other attachment (for example,
        "email"). This is a constant value: ''deleted''.'
      type: string
  - arguments: []
    description: Returns a list of searchable mailboxes. This command requires eDiscovery
      permissions to the Exchange Server. For more information, see the EWSv2 integration
      documentation.
    name: ews-get-searchable-mailboxes
    outputs:
    - contextPath: EWS.Mailboxes.mailbox
      description: Addresses of the searchable mailboxes.
      type: string
    - contextPath: EWS.Mailboxes.mailboxId
      description: IDs of the searchable mailboxes.
      type: string
    - contextPath: EWS.Mailboxes.displayName
      description: The email display name.
      type: string
    - contextPath: EWS.Mailboxes.isExternal
      description: Whether the mailbox is external.
      type: boolean
    - contextPath: EWS.Mailboxes.externalEmailAddress
      description: The external email address.
      type: string
  - arguments:
    - description: The filter query to search.
      name: filter
      required: true
    - description: The mailbox IDs to search. If empty, all mailboxes are searched.
      isArray: true
      name: mailbox-search-scope
    - defaultValue: "100"
      description: Maximum number of results to return. Default is 100. This maximum
        limit can vary based on the EWS server configuration, but a safe recommendation
        for this argument's upper value is 1000.
      name: limit
    - description: CSV list or array of email addresses.
      isArray: true
      name: email_addresses
    description: Searches over multiple mailboxes or all Exchange mailboxes. Use either
      the mailbox-search-scope command or the email-addresses command to search specific
      mailboxes. This command requires eDiscovery permissions to the Exchange Server.
      For more information, see the EWS v2 integration documentation.
    name: ews-search-mailboxes
    outputs:
    - contextPath: EWS.Items.itemId
      description: The item ID.
      type: string
    - contextPath: EWS.Items.mailbox
      description: The mailbox address where the item was found.
      type: string
    - contextPath: EWS.Items.subject
      description: The subject of the email.
      type: string
    - contextPath: EWS.Items.toRecipients
      description: List of recipient email addresses.
      type: Unknown
    - contextPath: EWS.Items.sender
      description: Sender email address.
      type: string
    - contextPath: EWS.Items.hasAttachments
      description: Whether the email has attachments?
      type: boolean
    - contextPath: EWS.Items.datetimeSent
      description: Sent time of the email.
      type: date
    - contextPath: EWS.Items.datetimeReceived
      description: Received time of the email.
      type: date
  - arguments:
    - description: The ID of the item to move.
      name: item-id
      required: true
    - description: The path to the folder to which to move the item. Complex paths
        are supported, for example, "Inbox\Phishing".
      name: target-folder-path
      required: true
    - description: The mailbox on which to run the command.
      name: target-mailbox
    - auto: PREDEFINED
      description: Whether the target folder is a public folder.
      name: is-public
      predefined:
      - "True"
      - "False"
    description: Move an item to different folder in the mailbox.
    name: ews-move-item
    outputs:
    - contextPath: EWS.Items.newItemID
      description: The item ID after move.
      type: string
    - contextPath: EWS.Items.messageID
      description: The item message ID.
      type: string
    - contextPath: EWS.Items.itemId
      description: The original item ID.
      type: string
    - contextPath: EWS.Items.action
      description: The action taken. The value will be "moved".
      type: string
  - arguments:
    - description: The item IDs to delete.
      name: item-ids
      required: true
    - defaultValue: soft
      description: Deletion type. Can be "trash", "soft", or "hard".
      name: delete-type
      required: true
    - description: The mailbox on which to run the command.
      name: target-mailbox
    description: Delete items from mailbox. This command requires eDiscovery permissions
      to the Exchange Server. For more information, see the EWSv2 integration documentation.
    name: ews-delete-items
    outputs:
    - contextPath: EWS.Items.itemId
      description: The deleted item ID.
      type: string
    - contextPath: EWS.Items.messageId
      description: The deleted message ID.
      type: string
    - contextPath: EWS.Items.action
      description: The deletion action. Can be 'trash-deleted', 'soft-deleted', or
        'hard-deleted'.
      type: string
  - arguments:
    - description: 'The search query string. For more information about the query
        syntax, see the Microsoft documentation: https://msdn.microsoft.com/en-us/library/ee693615.aspx'
      name: query
    - description: The folder path in which to search. If empty, searches all the
        folders in the mailbox.
      name: folder-path
    - defaultValue: "100"
      description: Maximum number of results to return.
      name: limit
    - description: The mailbox on which to apply the search.
      name: target-mailbox
    - auto: PREDEFINED
      description: Whether the folder is a Public Folder?
      name: is-public
      predefined:
      - "True"
      - "False"
    - description: The message ID of the email. This will be ignored if a query argument
        is provided.
      name: message-id
    - defaultValue: all
      description: A CSV list of fields to retrieve.
      isArray: true
      name: selected-fields
      predefined:
      - ""
    - auto: PREDEFINED
      description: Whether to surround the message ID with angle brackets (<>) if
        it does not exist. Default is 'True'.
      name: surround_id_with_angle_brackets
      predefined:
      - "True"
      - "False"
    description: Searches for items in the specified mailbox. Specific permissions
      are needed for this operation to search in a target mailbox other than the default.
    name: ews-search-mailbox
    outputs:
    - contextPath: EWS.Items.itemId
      description: The email item ID.
      type: string
    - contextPath: EWS.Items.hasAttachments
      description: Whether the email has attachments.
      type: boolean
    - contextPath: EWS.Items.datetimeReceived
      description: Received time of the email.
      type: date
    - contextPath: EWS.Items.datetimeSent
      description: Sent time of the email.
      type: date
    - contextPath: EWS.Items.headers
      description: Email headers (list).
      type: Unknown
    - contextPath: EWS.Items.sender
      description: Sender email address of the email.
      type: string
    - contextPath: EWS.Items.subject
      description: Subject of the email.
      type: string
    - contextPath: EWS.Items.textBody
      description: Body of the email (as text).
      type: string
    - contextPath: EWS.Items.size
      description: Email size.
      type: number
    - contextPath: EWS.Items.toRecipients
      description: List of email recipients addresses.
      type: Unknown
    - contextPath: EWS.Items.receivedBy
      description: Email received by address.
      type: Unknown
    - contextPath: EWS.Items.messageId
      description: Email message ID.
      type: string
    - contextPath: EWS.Items.body
      description: Body of the email (as HTML).
      type: string
    - contextPath: EWS.Items.FileAttachments.attachmentId
      description: Attachment ID of the file attachment.
      type: unknown
    - contextPath: EWS.Items.ItemAttachments.attachmentId
      description: Attachment ID of the item attachment.
      type: unknown
    - contextPath: EWS.Items.FileAttachments.attachmentName
      description: Attachment name of the file attachment.
      type: unknown
    - contextPath: EWS.Items.ItemAttachments.attachmentName
      description: Attachment name of the item attachment.
      type: unknown
    - contextPath: EWS.Items.isRead
      description: The read status of the email.
      type: String
  - arguments:
    - description: The mailbox for which to retrieve the contacts.
      name: target-mailbox
    - defaultValue: "100"
      description: Maximum number of results to return.
      name: limit
    description: Retrieves contacts for a specified mailbox.
    name: ews-get-contacts
    outputs:
    - contextPath: Account.Email.EwsContacts.displayName
      description: The contact name.
      type: Unknown
    - contextPath: Account.Email.EwsContacts.lastModifiedTime
      description: The time that the contact was last modified.
      type: Unknown
    - contextPath: Account.Email.EwsContacts.emailAddresses
      description: Phone numbers of the contact.
      type: Unknown
    - contextPath: Account.Email.EwsContacts.physicalAddresses
      description: Physical addresses of the contact.
      type: Unknown
    - contextPath: Account.Email.EwsContacts.phoneNumbers.phoneNumber
      description: Email addresses of the contact.
      type: Unknown
  - arguments:
    - description: The mailbox for which to get the out-of-office status.
      name: target-mailbox
      required: true
    description: Retrieves the out-of-office status for a specified mailbox.
    name: ews-get-out-of-office
    outputs:
    - contextPath: Account.Email.OutOfOffice.state
      description: 'Out-of-office state. Result can be: Enabled, Scheduled, Disabled.'
      type: Unknown
    - contextPath: Account.Email.OutOfOffice.externalAudience
      description: Out-of-office external audience. Can be "None", "Known", or "All".
      type: Unknown
    - contextPath: Account.Email.OutOfOffice.start
      description: Out-of-office start date.
      type: Unknown
    - contextPath: Account.Email.OutOfOffice.end
      description: Out-of-office end date.
      type: Unknown
    - contextPath: Account.Email.OutOfOffice.internalReply
      description: Out-of-office internal reply.
      type: Unknown
    - contextPath: Account.Email.OutOfOffice.externalReply
      description: Out-of-office external reply.
      type: Unknown
    - contextPath: Account.Email.OutOfOffice.mailbox
      description: Out-of-office mailbox.
      type: Unknown
  - arguments:
    - description: A CSV list of message IDs. Run the py-ews-delete-items command
        to retrieve the message IDs.
      name: message-ids
      required: true
    - defaultValue: Inbox
      description: The folder path to recover the messages to.
      name: target-folder-path
      required: true
    - description: The mailbox in which the messages found. If empty, will use the
        default mailbox. If you specify a different mailbox, you might need impersonation
        rights to the mailbox.
      name: target-mailbox
    - auto: PREDEFINED
      description: Whether the target folder is a Public Folder.
      name: is-public
      predefined:
      - "True"
      - "False"
    description: Recovers messages that were soft-deleted.
    name: ews-recover-messages
    outputs:
    - contextPath: EWS.Items.itemId
      description: The item ID of the recovered item.
      type: Unknown
    - contextPath: EWS.Items.messageId
      description: The message ID of the recovered item.
      type: Unknown
    - contextPath: EWS.Items.action
      description: The action taken on the item. The value will be 'recovered'.
      type: Unknown
  - arguments:
    - description: The name of the new folder.
      name: new-folder-name
      required: true
    - defaultValue: Inbox
      description: Path to locate the new folder. Exchange folder ID is also supported.
      name: folder-path
      required: true
    - description: The mailbox in which to create the folder.
      name: target-mailbox
    description: Creates a new folder in a specified mailbox.
    name: ews-create-folder
  - arguments:
    - description: The item ID to mark as junk.
      name: item-id
      required: true
    - auto: PREDEFINED
      defaultValue: "yes"
      description: Whether to move the item from the original folder to the junk folder.
      name: move-items
      predefined:
      - "yes"
      - "no"
    - description: If empty, will use the default mailbox. If you specify a different
        mailbox, you might need impersonation rights to the mailbox.
      name: target-mailbox
    description: 'Marks an item as junk. This is commonly used to block an email address.
      For more information, see the Microsoft documentation: https://msdn.microsoft.com/en-us/library/office/dn481311(v=exchg.150).aspx.'
    name: ews-mark-item-as-junk
  - arguments:
    - description: The mailbox on which to apply the command.
      name: target-mailbox
    - auto: PREDEFINED
      description: Whether to find Public Folders.
      name: is-public
      predefined:
      - "True"
      - "False"
    description: Retrieves information for folders for a specified mailbox. Only folders
      with read permissions will be returned. Your visual folders on the mailbox,
      such as "Inbox", are under the folder "Top of Information Store".
    name: ews-find-folders
    outputs:
    - contextPath: EWS.Folders.name
      description: Folder name.
      type: string
    - contextPath: EWS.Folders.id
      description: Folder ID.
      type: string
    - contextPath: EWS.Folders.totalCount
      description: Number of items in folder.
      type: Unknown
    - contextPath: EWS.Folders.unreadCount
      description: Number of unread items in folder.
      type: number
    - contextPath: EWS.Folders.changeKey
      description: Folder change key.
      type: number
    - contextPath: EWS.Folders.childrenFolderCount
      description: Number of sub-folders.
      type: number
  - arguments:
    - description: The folder path from which to get the items.
      name: folder-path
      required: true
    - defaultValue: "100"
      description: Maximum number of items to return.
      name: limit
    - description: The mailbox to on which to apply the command.
      name: target-mailbox
    - auto: PREDEFINED
      description: Whether the folder is a Public Folder. Default is 'False'.
      name: is-public
      predefined:
      - "True"
      - "False"
    - auto: PREDEFINED
      defaultValue: "no"
      description: If the email item contains another email as an attachment (EML
        or MSG file), whether to retrieve the EML/MSG file attachment. Can be "yes"
        or "no". Default is "no".
      name: get-internal-item
      predefined:
      - "yes"
      - "no"
    description: Retrieves items from a specified folder in a mailbox. The items are
      order by the item created time, most recent is first.
    name: ews-get-items-from-folder
    outputs:
    - contextPath: EWS.Items.itemId
      description: The item ID of the email.
      type: string
    - contextPath: EWS.Items.hasAttachments
      description: Whether the email has attachments.
      type: boolean
    - contextPath: EWS.Items.datetimeReceived
      description: Received time of the email.
      type: date
    - contextPath: EWS.Items.datetimeSent
      description: Sent time of the email.
      type: date
    - contextPath: EWS.Items.headers
      description: Email headers (list).
      type: Unknown
    - contextPath: EWS.Items.sender
      description: Sender mail address of the email.
      type: string
    - contextPath: EWS.Items.subject
      description: Subject of the email.
      type: string
    - contextPath: EWS.Items.textBody
      description: Body of the email (as text).
      type: string
    - contextPath: EWS.Items.size
      description: Email size.
      type: number
    - contextPath: EWS.Items.toRecipients
      description: Email recipients addresses (list).
      type: Unknown
    - contextPath: EWS.Items.receivedBy
      description: Received by address of the email.
      type: Unknown
    - contextPath: EWS.Items.messageId
      description: Email message ID.
      type: string
    - contextPath: EWS.Items.body
      description: Body of the email (as HTML).
      type: string
    - contextPath: EWS.Items.FileAttachments.attachmentId
      description: Attachment ID of file attachment.
      type: unknown
    - contextPath: EWS.Items.ItemAttachments.attachmentId
      description: Attachment ID of the item attachment.
      type: unknown
    - contextPath: EWS.Items.FileAttachments.attachmentName
      description: Attachment name of the file attachment.
      type: unknown
    - contextPath: EWS.Items.ItemAttachments.attachmentName
      description: Attachment name of the item attachment.
      type: unknown
    - contextPath: EWS.Items.isRead
      description: The read status of the email.
      type: String
    - contextPath: EWS.Items.categories
      description: The categories of the email.
      type: unknown
  - arguments:
    - description: 'The text value of this argument is used to resolve names against
        the following fields: First name, Last name, Display name, Full name, Office,
        Alias, SMTP address. Eg. `John Doe` or `sip:johndoe@example.com`.'
      name: identifier
      required: true
    - auto: PREDEFINED
      defaultValue: "True"
      description: Describes whether the full contact details for public contacts
        for a resolved name are returned.
      name: full-contact-data
      predefined:
      - "True"
      - "False"
    description: This operation verifies aliases and matches display names to the
      correct mailbox user. It handles one ambiguous name at a time. If there are
      multiple potential matches, all will be returned, but limited to a maximum of
      100 candidates.
    name: ews-resolve-name
    outputs:
    - contextPath: EWS.ResolvedNames.FullContactInfo.contactSource
      description: Whether the contact is located in the Exchange store or Active
        Directory Domain Services (AD DS).
      type: String
    - contextPath: EWS.ResolvedNames.FullContactInfo.culture
      description: Represents the culture for a given item in a mailbox.
      type: String
    - contextPath: EWS.ResolvedNames.FullContactInfo.displayName
      description: The display name of a contact.
      type: String
    - contextPath: EWS.ResolvedNames.FullContactInfo.ItemId
      description: Contains the unique identifier and change key of an item in the
        Exchange store.
      type: String
    - contextPath: EWS.ResolvedNames.FullContactInfo.emailAddresses
      description: Represents a collection of email addresses for a contact.
      type: String
    - contextPath: EWS.ResolvedNames.FullContactInfo.givenName
      description: Contains a contact's given name.
      type: String
    - contextPath: EWS.ResolvedNames.FullContactInfo.importance
      description: Describes the importance of an item.
      type: String
    - contextPath: EWS.ResolvedNames.FullContactInfo.initials
      description: Represents the initials of a contact.
      type: String
    - contextPath: EWS.ResolvedNames.FullContactInfo.phoneNumbers.label
      description: 'The following are the possible values for this attribute: AssistantPhone,
        BusinessFax, BusinessPhone, BusinessPhone2, Callback, CarPhone, CompanyMainPhone,
        HomeFax, HomePhone, HomePhone2, Isdn, MobilePhone, OtherFax, OtherTelephone,
        Pager, PrimaryPhone, RadioPhone, Telex, TtyTddPhone.'
      type: String
    - contextPath: EWS.ResolvedNames.FullContactInfo.phoneNumbers.phoneNumber
      description: The phone number of the contact.
      type: String
    - contextPath: EWS.ResolvedNames.FullContactInfo.physicalAddresses.city
      description: The physical addresses city associated with the contact.
      type: String
    - contextPath: EWS.ResolvedNames.FullContactInfo.physicalAddresses.country
      description: The physical addresses country associated with the contact.
      type: String
    - contextPath: EWS.ResolvedNames.FullContactInfo.physicalAddresses.label
      description: The physical addresses label associated with the contact.
      type: String
    - contextPath: EWS.ResolvedNames.FullContactInfo.physicalAddresses.state
      description: The physical addresses state associated with the contact.
      type: String
    - contextPath: EWS.ResolvedNames.FullContactInfo.physicalAddresses.street
      description: The physical addresses street associated with the contact.
      type: String
    - contextPath: EWS.ResolvedNames.FullContactInfo.physicalAddresses.zipcode
      description: The physical addresses zipcode associated with the contact.
      type: String
    - contextPath: EWS.ResolvedNames.FullContactInfo.postalAddressIndex
      description: Represents the display types for physical addresses.
      type: String
    - contextPath: EWS.ResolvedNames.FullContactInfo.sensitivity
      description: Indicates the sensitivity level of an item.
      type: String
    - contextPath: EWS.ResolvedNames.email_address
      description: The primary SMTP address of a mailbox user.
      type: String
    - contextPath: EWS.ResolvedNames.mailbox_type
      description: The type of mailbox that is represented by the email address.
      type: String
    - contextPath: EWS.ResolvedNames.name
      description: The name of a mailbox user.
      type: String
    - contextPath: EWS.ResolvedNames.routing_type
      description: The address type for the mailbox.
      type: String
  - arguments:
    - description: A CSV list if item IDs.
      isArray: true
      name: item-ids
      required: true
    - description: The mailbox on which to run the command on.
      name: target-mailbox
    description: Retrieves items by item ID.
    name: ews-get-items
    outputs:
    - contextPath: EWS.Items.itemId
      description: The email item ID.
      type: string
    - contextPath: EWS.Items.hasAttachments
      description: Whether the email has attachments.
      type: boolean
    - contextPath: EWS.Items.datetimeReceived
      description: Received time of the email.
      type: date
    - contextPath: EWS.Items.datetimeSent
      description: Sent time of the email.
      type: date
    - contextPath: EWS.Items.headers
      description: Email headers (list).
      type: Unknown
    - contextPath: EWS.Items.sender
      description: Sender mail address of the email.
      type: string
    - contextPath: EWS.Items.subject
      description: Subject of the email.
      type: string
    - contextPath: EWS.Items.textBody
      description: Body of the email (as text).
      type: string
    - contextPath: EWS.Items.size
      description: Email size.
      type: number
    - contextPath: EWS.Items.toRecipients
      description: Email recipients addresses (list).
      type: Unknown
    - contextPath: EWS.Items.receivedBy
      description: Received by address of the email.
      type: Unknown
    - contextPath: EWS.Items.messageId
      description: Email message ID.
      type: string
    - contextPath: EWS.Items.body
      description: Body of the email (as HTML).
      type: string
    - contextPath: EWS.Items.FileAttachments.attachmentId
      description: Attachment ID of the file attachment.
      type: unknown
    - contextPath: EWS.Items.ItemAttachments.attachmentId
      description: Attachment ID of the item attachment.
      type: unknown
    - contextPath: EWS.Items.FileAttachments.attachmentName
      description: Attachment name of the file attachment.
      type: unknown
    - contextPath: EWS.Items.ItemAttachments.attachmentName
      description: Attachment name of the item attachment.
      type: unknown
    - contextPath: EWS.Items.isRead
      description: The read status of the email.
      type: String
    - contextPath: Email.CC
      description: Email addresses CC'ed to the email.
      type: String
    - contextPath: Email.BCC
      description: Email addresses BCC'ed to the email.
      type: String
    - contextPath: Email.To
      description: The recipient of the email.
      type: String
    - contextPath: Email.From
      description: The sender of the email.
      type: String
    - contextPath: Email.Subject
      description: The subject of the email.
      type: String
    - contextPath: Email.Text
      description: The plain-text version of the email.
      type: String
    - contextPath: Email.HTML
      description: The HTML version of the email.
      type: String
    - contextPath: Email.HeadersMap
      description: The headers of the email.
      type: String
    - contextPath: EWS.Items.categories
      description: The categories of the email.
      type: unknown
  - arguments:
    - description: The item ID to move.
      name: item-id
      required: true
    - description: The folder in the destination mailbox to which to move the item.
        You can specify a complex path, for example, "Inbox\Phishing".
      name: destination-folder-path
      required: true
    - description: The mailbox to which to move the item.
      name: destination-mailbox
      required: true
    - description: The mailbox from which to move the item (conventionally called
        the "target-mailbox", the target mailbox on which to run the command).
      name: source-mailbox
    - auto: PREDEFINED
      description: Whether the destination folder is a Public Folder. Default is "False".
      name: is-public
      predefined:
      - "True"
      - "False"
    description: Moves an item from one mailbox to different mailbox.
    name: ews-move-item-between-mailboxes
    outputs:
    - contextPath: EWS.Items.movedToMailbox
      description: The mailbox wo which the item was moved.
      type: string
    - contextPath: EWS.Items.movedToFolder
      description: The folder to which the item was moved.
      type: string
    - contextPath: EWS.Items.action
      description: The action taken on the item. The value will be "moved".
      type: string
  - arguments:
    - description: The mailbox on which to apply the search.
      name: target-mailbox
    - default: true
      defaultValue: AllItems
      description: The path of the folder to retrieve. If empty, will retrieve the
        folder "AllItems".
      name: folder-path
    - auto: PREDEFINED
      description: Whether the folder is a Public Folder. Default is "False".
      name: is-public
      predefined:
      - "True"
      - "False"
    description: Retrieves a single folder.
    name: ews-get-folder
    outputs:
    - contextPath: EWS.Folders.id
      description: Folder ID.
      type: string
    - contextPath: EWS.Folders.name
      description: Folder name.
      type: string
    - contextPath: EWS.Folders.changeKey
      description: Folder change key.
      type: string
    - contextPath: EWS.Folders.totalCount
      description: Total number of emails in the folder.
      type: number
    - contextPath: EWS.Folders.childrenFolderCount
      description: Number of sub-folders.
      type: number
    - contextPath: EWS.Folders.unreadCount
      description: Number of unread emails in the folder.
      type: number
  - arguments: []
    description: Returns the auto-discovery information. Can be used to manually configure
      the Exchange Server.
    name: ews-get-autodiscovery-config
  - arguments:
    - description: Email address of the group to expand.
      name: email-address
      required: true
    - auto: PREDEFINED
      defaultValue: "False"
      description: Whether to enable recursive expansion. Default is "False".
      name: recursive-expansion
      predefined:
      - "True"
      - "False"
    description: Expands a distribution list to display all members. By default, expands
      only first layer of the distribution list. If recursive-expansion is "True",
      the command expands nested distribution lists and returns all members.
    name: ews-expand-group
  - arguments:
    - description: A CSV list of item IDs.
      isArray: true
      name: item-ids
      required: true
    - auto: PREDEFINED
      defaultValue: read
      description: How to mark the item. Can be "read" or "unread". Default is "read".
      name: operation
      predefined:
      - read
      - unread
    - description: The mailbox on which to run the command. If empty, the command
        will be applied on the default mailbox.
      name: target-mailbox
    description: Marks items as read or unread.
    name: ews-mark-items-as-read
    outputs:
    - contextPath: EWS.Items.action
      description: The action that was performed on item.
      type: String
    - contextPath: EWS.Items.itemId
      description: The ID of the item.
      type: String
    - contextPath: EWS.Items.messageId
      description: The message ID of the item.
      type: String
  - arguments:
    - description: The item ID of item to upload as and EML file.
      name: item-id
      required: true
    - description: The mailbox in which this email was found. If empty, the default
        mailbox is used. Otherwise the user might require impersonation rights to
        this mailbox.
      name: target-mailbox
    description: Retrieves items by item ID and uploads it's content as eml file.
    name: ews-get-items-as-eml
    outputs:
    - contextPath: File.Size
      description: The size of the file.
      type: String
    - contextPath: File.SHA1
      description: The SHA1 hash of the file.
      type: String
    - contextPath: File.SHA256
      description: The SHA256 hash of the file.
      type: String
    - contextPath: File.SHA512
      description: The SHA512 hash of the file.
      type: String
    - contextPath: File.Name
      description: The name of the file.
      type: String
    - contextPath: File.SSDeep
      description: The SSDeep hash of the file.
      type: String
    - contextPath: File.EntryID
      description: EntryID of the file.
      type: String
    - contextPath: File.Info
      description: Information about the file.
      type: String
    - contextPath: File.Type
      description: The file type.
      type: String
    - contextPath: File.MD5
      description: The MD5 hash of the file.
      type: String
    - contextPath: File.Extension
      description: The extension of the file.
      type: String
  - arguments:
    - description: A CSV list of email addresses for the 'to' field.
      name: to
      required: true
    - description: A CSV list of email addresses for the 'cc' field.
      name: cc
    - description: A CSV list of email addresses for the 'bcc' field.
      name: bcc
    - description: Subject for the email to be sent.
      name: subject
      required: true
    - description: The email address specified in the 'reply to' field.
      name: replyTo
    - description: The contents (body) of the email to send. This argument overrides
        the "htmlBody" argument if the "bodyType" argument is Text.
      name: body
    - description: HTML formatted content (body) of the email to be sent. This argument
        overrides the "body" argument if the "bodyType" argument is HTML.
      name: htmlBody
    - auto: PREDEFINED
      defaultValue: Text
      description: Whether message response body type is Text, or HTML.
      name: bodyType
      predefined:
      - Text
      - HTML
    - description: 'A CSV list of War Room entry IDs that contain files, and are used
        to attach files to the outgoing email. For example: attachIDs=15@8,19@8.'
      isArray: true
      name: attachIDs
    - description: A CSV list of names of attachments to send. Should be the same
        number of elements as attachIDs.
      isArray: true
      name: attachNames
    - description: A CSV list of CIDs to embed attachments within the email itself.
      isArray: true
      name: attachCIDs
    - description: Raw email message from MimeContent type.
      name: raw_message
    - description: The email address from which to send mail.
      name: from
    - auto: PREDEFINED
      defaultValue: "True"
      description: Whether to handle inline images in the HTML body. When set to 'True',
        inline images will be extracted from the HTML body and will be attached to
        the email as an inline attachment object.
      name: handle_inline_image
      predefined:
      - "True"
      - "False"
    description: Sends an email using EWS.
    name: send-mail
  - arguments:
    - description: ID of the item to reply to.
      name: inReplyTo
      required: true
    - description: A CSV list of email addresses for the 'to' field.
      isArray: true
      name: to
      required: true
    - description: A CSV list of email addresses for the 'cc' field.
      isArray: true
      name: cc
    - description: A CSV list of email addresses for the 'bcc' field.
      isArray: true
      name: bcc
    - description: Subject for the email to be sent.
      name: subject
    - description: The contents (body) of the email to be sent.
      name: body
    - description: HTML formatted content (body) of the email to be sent. This argument
        overrides the "body" argument.
      name: htmlBody
    - auto: PREDEFINED
      description: Indicates whether to render the email body.
      name: renderBody
      predefined:
      - "true"
      - "false"
    - description: 'A CSV list of War Room entry IDs that contain files, and are used
        to attach files to the outgoing email. For example: attachIDs=15@8,19@8.'
      isArray: true
      name: attachIDs
    - description: A CSV list of names of attachments to send. Should be the same
        number of elements as attachIDDs.
      isArray: true
      name: attachNames
    - description: A CSV list of CIDs to embed attachments within the email itself.
      isArray: true
      name: attachCIDs
    - description: The email address from which to reply.
      name: from
    - auto: PREDEFINED
      defaultValue: "True"
      description: Whether to handle inline images in the HTML body. When set to 'True',
        inline images are extracted from the HTML body and attached to the email as
        an inline attachment object.
      name: handle_inline_image
      predefined:
      - "True"
      - "False"
    description: Replies to an email using EWS.
    name: reply-mail
  dockerimage: demisto/py-ews:5.5.0.118073
  isfetch: true
  runonce: false
  script: |
    register_module_line('EWS v2', 'start', __line__())
    CONSTANT_PACK_VERSION = '2.2.6'
    demisto.debug('pack id = MicrosoftExchangeOnPremise, pack version = 2.2.6')
    import email
    import hashlib
    from email.policy import SMTP, SMTPUTF8
    from io import StringIO
    from multiprocessing import Process

    import dateparser  # type: ignore
    import exchangelib


    ### GENERATED CODE ###: from EWSApiModule import *
    # This code was inserted in place of an API module.
    register_module_line('EWSApiModule', 'start', __line__(), wrapper=-3)
    import uuid
    from enum import Enum
    from urllib.parse import urlparse


    from exchangelib import (
        BASIC,
        DIGEST,
        NTLM,
        OAUTH2,
        Account,
        Build,
        Configuration,
        Credentials,
        FileAttachment,
        Folder,
        HTMLBody,
        Identity,
        Version,
    )
    from exchangelib.credentials import BaseCredentials, OAuth2AuthorizationCodeCredentials
    from exchangelib.errors import (
        AutoDiscoverFailed,
        ErrorInvalidIdMalformed,
        ErrorItemNotFound,
        ErrorNameResolutionNoResults,
        ResponseMessageError,
    )
    from exchangelib.folders.base import BaseFolder
    from exchangelib.items import Item, Message
    from exchangelib.protocol import BaseProtocol, FaultTolerance, Protocol
    from exchangelib.services.common import EWSAccountService, EWSService
    from exchangelib.util import MNS, TNS, add_xml_child, create_element
    from exchangelib.version import (
        EXCHANGE_2007,
        EXCHANGE_2010,
        EXCHANGE_2010_SP2,
        EXCHANGE_2013,
        EXCHANGE_2013_SP1,
        EXCHANGE_2016,
        EXCHANGE_2019,
        EXCHANGE_O365,
    )

    ### GENERATED CODE ###: from MicrosoftApiModule import *
    # This code was inserted in place of an API module.
    register_module_line('MicrosoftApiModule', 'start', __line__(), wrapper=-3)
    import base64
    import re

    # pylint: disable=E9010, E9011
    import traceback


    import requests

    from cryptography.hazmat.primitives.ciphers.aead import AESGCM




    class Scopes:
        graph = "https://graph.microsoft.com/.default"
        security_center = "https://api.securitycenter.windows.com/.default"
        security_center_apt_service = "https://securitycenter.onmicrosoft.com/windowsatpservice/.default"
        management_azure = "https://management.azure.com/.default"  # resource_manager


    class Resources:
        graph = "https://graph.microsoft.com/"
        security_center = "https://api.securitycenter.microsoft.com/"
        security = "https://api.security.microsoft.com/"
        management_azure = "https://management.azure.com/"  # resource_manager
        manage_office = "https://manage.office.com/"


    # authorization types
    OPROXY_AUTH_TYPE = "oproxy"
    SELF_DEPLOYED_AUTH_TYPE = "self_deployed"

    # grant types in self-deployed authorization
    CLIENT_CREDENTIALS = "client_credentials"
    AUTHORIZATION_CODE = "authorization_code"
    REFRESH_TOKEN = "refresh_token"  # guardrails-disable-line
    DEVICE_CODE = "urn:ietf:params:oauth:grant-type:device_code"
    REGEX_SEARCH_URL = r"(?P<url>https?://[^\s]+)"
    REGEX_SEARCH_ERROR_DESC = r"^[^:]+:\s(?P<desc>.*?)(?:\s*Trace ID:| Correlation ID:| Timestamp:|$)"
    SESSION_STATE = "session_state"

    # Deprecated, prefer using AZURE_CLOUDS
    TOKEN_RETRIEVAL_ENDPOINTS = {
        "com": "https://login.microsoftonline.com",
        "gcc": "https://login.microsoftonline.com",
        "gcc-high": "https://login.microsoftonline.us",
        "dod": "https://login.microsoftonline.us",
        "de": "https://login.microsoftonline.de",
        "cn": "https://login.chinacloudapi.cn",
    }

    # Deprecated, prefer using AZURE_CLOUDS
    GRAPH_ENDPOINTS = {
        "com": "https://graph.microsoft.com",
        "gcc": "https://graph.microsoft.us",
        "gcc-high": "https://graph.microsoft.us",
        "dod": "https://dod-graph.microsoft.us",
        "de": "https://graph.microsoft.de",
        "cn": "https://microsoftgraph.chinacloudapi.cn",
    }

    # Deprecated, prefer using AZURE_CLOUDS
    GRAPH_BASE_ENDPOINTS = {
        "https://graph.microsoft.com": "com",
        # can't create an entry here for 'gcc' as the url is the same for both 'gcc' and 'gcc-high'
        "https://graph.microsoft.us": "gcc-high",
        "https://dod-graph.microsoft.us": "dod",
        "https://graph.microsoft.de": "de",
        "https://microsoftgraph.chinacloudapi.cn": "cn",
    }

    MICROSOFT_DEFENDER_FOR_ENDPOINT_TYPE = {
        "Worldwide": "com",
        "US Geo Proximity": "geo-us",
        "EU Geo Proximity": "geo-eu",
        "UK Geo Proximity": "geo-uk",
        "US GCC": "gcc",
        "US GCC-High": "gcc-high",
        "DoD": "dod",
    }

    MICROSOFT_DEFENDER_FOR_ENDPOINT_TYPE_CUSTOM = "Custom"
    MICROSOFT_DEFENDER_FOR_ENDPOINT_DEFAULT_ENDPOINT_TYPE = "com"


    # https://learn.microsoft.com/en-us/microsoft-365/security/defender/api-supported?view=o365-worldwide#endpoint-uris
    # https://learn.microsoft.com/en-us/microsoft-365/security/defender-endpoint/gov?view=o365-worldwide#api
    MICROSOFT_DEFENDER_FOR_ENDPOINT_API = {
        "com": "https://api.securitycenter.microsoft.com",
        "geo-us": "https://api.securitycenter.microsoft.com",
        "geo-eu": "https://api-eu.securitycenter.microsoft.com",
        "geo-uk": "https://api-uk.securitycenter.microsoft.com",
        "gcc": "https://api-gcc.securitycenter.microsoft.us",
        "gcc-high": "https://api-gov.securitycenter.microsoft.us",
        "dod": "https://api-gov.securitycenter.microsoft.us",
    }

    # https://learn.microsoft.com/en-us/graph/deployments#app-registration-and-token-service-root-endpoints
    MICROSOFT_DEFENDER_FOR_ENDPOINT_TOKEN_RETRIVAL_ENDPOINTS = {
        "com": "https://login.microsoftonline.com",
        "geo-us": "https://login.microsoftonline.com",
        "geo-eu": "https://login.microsoftonline.com",
        "geo-uk": "https://login.microsoftonline.com",
        "gcc": "https://login.microsoftonline.com",
        "gcc-high": "https://login.microsoftonline.us",
        "dod": "https://login.microsoftonline.us",
    }

    # https://learn.microsoft.com/en-us/graph/deployments#microsoft-graph-and-graph-explorer-service-root-endpoints
    MICROSOFT_DEFENDER_FOR_ENDPOINT_GRAPH_ENDPOINTS = {
        "com": "https://graph.microsoft.com",
        "geo-us": "https://graph.microsoft.com",
        "geo-eu": "https://graph.microsoft.com",
        "geo-uk": "https://graph.microsoft.com",
        "gcc": "https://graph.microsoft.com",
        "gcc-high": "https://graph.microsoft.us",
        "dod": "https://dod-graph.microsoft.us",
    }

    MICROSOFT_DEFENDER_FOR_ENDPOINT_APT_SERVICE_ENDPOINTS = {
        "com": "https://securitycenter.onmicrosoft.com",
        "geo-us": "https://securitycenter.onmicrosoft.com",
        "geo-eu": "https://securitycenter.onmicrosoft.com",
        "geo-uk": "https://securitycenter.onmicrosoft.com",
        "gcc": "https://securitycenter.onmicrosoft.com",
        "gcc-high": "https://securitycenter.onmicrosoft.us",
        "dod": "https://securitycenter.onmicrosoft.us",
    }

    MICROSOFT_DEFENDER_FOR_APPLICATION_API = {
        "com": "https://api.securitycenter.microsoft.com",
        "gcc": "https://api-gcc.securitycenter.microsoft.us",
        "gcc-high": "https://api-gcc.securitycenter.microsoft.us",
    }


    MICROSOFT_DEFENDER_FOR_APPLICATION_TYPE = {
        "Worldwide": "com",
        "US GCC": "gcc",
        "US GCC-High": "gcc-high",
    }

    MICROSOFT_DEFENDER_FOR_APPLICATION_TOKEN_RETRIEVAL_ENDPOINTS = {
        "com": "https://login.microsoftonline.com",
        "gcc": "https://login.microsoftonline.com",
        "gcc-high": "https://login.microsoftonline.us",
    }

    # Azure Managed Identities
    MANAGED_IDENTITIES_TOKEN_URL = "http://169.254.169.254/metadata/identity/oauth2/token?api-version=2018-02-01"
    MANAGED_IDENTITIES_SYSTEM_ASSIGNED = "SYSTEM_ASSIGNED"
    TOKEN_EXPIRED_ERROR_CODES = {
        50173,
        700082,
        70008,
        54005,
        7000222,
    }  # See: https://login.microsoftonline.com/error?code=

    # Moderate Retry Mechanism
    MAX_DELAY_REQUEST_COUNTER = 6


    class CloudEndpointNotSetException(Exception):
        pass


    class CloudSuffixNotSetException(Exception):
        pass


    class AzureCloudEndpoints:  # pylint: disable=too-few-public-methods,too-many-instance-attributes
        def __init__(
            self,  # pylint: disable=unused-argument
            management=None,
            resource_manager=None,
            sql_management=None,
            batch_resource_id=None,
            gallery=None,
            active_directory=None,
            active_directory_resource_id=None,
            active_directory_graph_resource_id=None,
            microsoft_graph_resource_id=None,
            active_directory_data_lake_resource_id=None,
            vm_image_alias_doc=None,
            media_resource_id=None,
            ossrdbms_resource_id=None,
            log_analytics_resource_id=None,
            app_insights_resource_id=None,
            app_insights_telemetry_channel_resource_id=None,
            synapse_analytics_resource_id=None,
            attestation_resource_id=None,
            portal=None,
            keyvault=None,
            exchange_online=None,
        ):
            # Attribute names are significant. They are used when storing/retrieving clouds from config
            self.management = management
            self.resource_manager = resource_manager
            self.sql_management = sql_management
            self.batch_resource_id = batch_resource_id
            self.gallery = gallery
            self.active_directory = active_directory
            self.active_directory_resource_id = active_directory_resource_id
            self.active_directory_graph_resource_id = active_directory_graph_resource_id
            self.microsoft_graph_resource_id = microsoft_graph_resource_id
            self.active_directory_data_lake_resource_id = active_directory_data_lake_resource_id
            self.vm_image_alias_doc = vm_image_alias_doc
            self.media_resource_id = media_resource_id
            self.ossrdbms_resource_id = ossrdbms_resource_id
            self.log_analytics_resource_id = log_analytics_resource_id
            self.app_insights_resource_id = app_insights_resource_id
            self.app_insights_telemetry_channel_resource_id = app_insights_telemetry_channel_resource_id
            self.synapse_analytics_resource_id = synapse_analytics_resource_id
            self.attestation_resource_id = attestation_resource_id
            self.portal = portal
            self.keyvault = keyvault
            self.exchange_online = exchange_online

        def has_endpoint_set(self, endpoint_name):
            try:
                # Can't simply use hasattr here as we override __getattribute__ below.
                # Python 3 hasattr() only returns False if an AttributeError is raised, but we raise
                # CloudEndpointNotSetException. This exception is not a subclass of AttributeError.
                getattr(self, endpoint_name)
                return True
            except Exception:  # pylint: disable=broad-except
                return False

        def __getattribute__(self, name):
            val = object.__getattribute__(self, name)
            if val is None:
                raise CloudEndpointNotSetException("The endpoint '{}' for this cloud is not set but is used.")
            return val


    class AzureCloudSuffixes:  # pylint: disable=too-few-public-methods,too-many-instance-attributes
        def __init__(
            self,  # pylint: disable=unused-argument
            storage_endpoint=None,
            storage_sync_endpoint=None,
            keyvault_dns=None,
            mhsm_dns=None,
            sql_server_hostname=None,
            azure_datalake_store_file_system_endpoint=None,
            azure_datalake_analytics_catalog_and_job_endpoint=None,
            acr_login_server_endpoint=None,
            mysql_server_endpoint=None,
            postgresql_server_endpoint=None,
            mariadb_server_endpoint=None,
            synapse_analytics_endpoint=None,
            attestation_endpoint=None,
        ):
            # Attribute names are significant. They are used when storing/retrieving clouds from config
            self.storage_endpoint = storage_endpoint
            self.storage_sync_endpoint = storage_sync_endpoint
            self.keyvault_dns = keyvault_dns
            self.mhsm_dns = mhsm_dns
            self.sql_server_hostname = sql_server_hostname
            self.mysql_server_endpoint = mysql_server_endpoint
            self.postgresql_server_endpoint = postgresql_server_endpoint
            self.mariadb_server_endpoint = mariadb_server_endpoint
            self.azure_datalake_store_file_system_endpoint = azure_datalake_store_file_system_endpoint
            self.azure_datalake_analytics_catalog_and_job_endpoint = azure_datalake_analytics_catalog_and_job_endpoint
            self.acr_login_server_endpoint = acr_login_server_endpoint
            self.synapse_analytics_endpoint = synapse_analytics_endpoint
            self.attestation_endpoint = attestation_endpoint

        def __getattribute__(self, name):
            val = object.__getattribute__(self, name)
            if val is None:
                raise CloudSuffixNotSetException("The suffix '{}' for this cloud is not set but is used.")
            return val


    class AzureCloud:  # pylint: disable=too-few-public-methods
        """Represents an Azure Cloud instance"""

        def __init__(self, origin, name, abbreviation, endpoints=None, suffixes=None):
            self.name = name
            self.abbreviation = abbreviation
            self.origin = origin
            self.endpoints = endpoints or AzureCloudEndpoints()
            self.suffixes = suffixes or AzureCloudSuffixes()


    AZURE_WORLDWIDE_CLOUD = AzureCloud(
        "Embedded",
        "AzureCloud",
        "com",
        endpoints=AzureCloudEndpoints(
            management="https://management.core.windows.net/",
            resource_manager="https://management.azure.com/",
            sql_management="https://management.core.windows.net:8443/",
            batch_resource_id="https://batch.core.windows.net/",
            gallery="https://gallery.azure.com/",
            active_directory="https://login.microsoftonline.com",
            active_directory_resource_id="https://management.core.windows.net/",
            active_directory_graph_resource_id="https://graph.windows.net/",
            microsoft_graph_resource_id="https://graph.microsoft.com/",
            active_directory_data_lake_resource_id="https://datalake.azure.net/",
            vm_image_alias_doc="https://raw.githubusercontent.com/Azure/azure-rest-api-specs/main/arm-compute/quickstart-templates/aliases.json",  # noqa: E501
            media_resource_id="https://rest.media.azure.net",
            ossrdbms_resource_id="https://ossrdbms-aad.database.windows.net",
            app_insights_resource_id="https://api.applicationinsights.io",
            log_analytics_resource_id="https://api.loganalytics.io",
            app_insights_telemetry_channel_resource_id="https://dc.applicationinsights.azure.com/v2/track",
            synapse_analytics_resource_id="https://dev.azuresynapse.net",
            attestation_resource_id="https://attest.azure.net",
            portal="https://portal.azure.com",
            keyvault="https://vault.azure.net",
            exchange_online="https://outlook.office365.com",
        ),
        suffixes=AzureCloudSuffixes(
            storage_endpoint="core.windows.net",
            storage_sync_endpoint="afs.azure.net",
            keyvault_dns=".vault.azure.net",
            mhsm_dns=".managedhsm.azure.net",
            sql_server_hostname=".database.windows.net",
            mysql_server_endpoint=".mysql.database.azure.com",
            postgresql_server_endpoint=".postgres.database.azure.com",
            mariadb_server_endpoint=".mariadb.database.azure.com",
            azure_datalake_store_file_system_endpoint="azuredatalakestore.net",
            azure_datalake_analytics_catalog_and_job_endpoint="azuredatalakeanalytics.net",
            acr_login_server_endpoint=".azurecr.io",
            synapse_analytics_endpoint=".dev.azuresynapse.net",
            attestation_endpoint=".attest.azure.net",
        ),
    )

    AZURE_US_GCC_CLOUD = AzureCloud(
        "Embedded",
        "AzureUSGovernment",
        "gcc",
        endpoints=AzureCloudEndpoints(
            management="https://management.core.usgovcloudapi.net/",
            resource_manager="https://management.usgovcloudapi.net/",
            sql_management="https://management.core.usgovcloudapi.net:8443/",
            batch_resource_id="https://batch.core.usgovcloudapi.net/",
            gallery="https://gallery.usgovcloudapi.net/",
            active_directory="https://login.microsoftonline.com",
            active_directory_resource_id="https://management.core.usgovcloudapi.net/",
            active_directory_graph_resource_id="https://graph.windows.net/",
            microsoft_graph_resource_id="https://graph.microsoft.us/",
            vm_image_alias_doc="https://raw.githubusercontent.com/Azure/azure-rest-api-specs/main/arm-compute/quickstart-templates/aliases.json",  # noqa: E501
            media_resource_id="https://rest.media.usgovcloudapi.net",
            ossrdbms_resource_id="https://ossrdbms-aad.database.usgovcloudapi.net",
            app_insights_resource_id="https://api.applicationinsights.us",
            log_analytics_resource_id="https://api.loganalytics.us",
            app_insights_telemetry_channel_resource_id="https://dc.applicationinsights.us/v2/track",
            synapse_analytics_resource_id="https://dev.azuresynapse.usgovcloudapi.net",
            portal="https://portal.azure.us",
            keyvault="https://vault.usgovcloudapi.net",
            exchange_online="https://outlook.office365.com",
        ),
        suffixes=AzureCloudSuffixes(
            storage_endpoint="core.usgovcloudapi.net",
            storage_sync_endpoint="afs.azure.us",
            keyvault_dns=".vault.usgovcloudapi.net",
            mhsm_dns=".managedhsm.usgovcloudapi.net",
            sql_server_hostname=".database.usgovcloudapi.net",
            mysql_server_endpoint=".mysql.database.usgovcloudapi.net",
            postgresql_server_endpoint=".postgres.database.usgovcloudapi.net",
            mariadb_server_endpoint=".mariadb.database.usgovcloudapi.net",
            acr_login_server_endpoint=".azurecr.us",
            synapse_analytics_endpoint=".dev.azuresynapse.usgovcloudapi.net",
        ),
    )

    AZURE_US_GCC_HIGH_CLOUD = AzureCloud(
        "Embedded",
        "AzureUSGovernment",
        "gcc-high",
        endpoints=AzureCloudEndpoints(
            management="https://management.core.usgovcloudapi.net/",
            resource_manager="https://management.usgovcloudapi.net/",
            sql_management="https://management.core.usgovcloudapi.net:8443/",
            batch_resource_id="https://batch.core.usgovcloudapi.net/",
            gallery="https://gallery.usgovcloudapi.net/",
            active_directory="https://login.microsoftonline.us",
            active_directory_resource_id="https://management.core.usgovcloudapi.net/",
            active_directory_graph_resource_id="https://graph.windows.net/",
            microsoft_graph_resource_id="https://graph.microsoft.us/",
            vm_image_alias_doc="https://raw.githubusercontent.com/Azure/azure-rest-api-specs/main/arm-compute/quickstart-templates/aliases.json",  # noqa: E501
            media_resource_id="https://rest.media.usgovcloudapi.net",
            ossrdbms_resource_id="https://ossrdbms-aad.database.usgovcloudapi.net",
            app_insights_resource_id="https://api.applicationinsights.us",
            log_analytics_resource_id="https://api.loganalytics.us",
            app_insights_telemetry_channel_resource_id="https://dc.applicationinsights.us/v2/track",
            synapse_analytics_resource_id="https://dev.azuresynapse.usgovcloudapi.net",
            portal="https://portal.azure.us",
            keyvault="https://vault.usgovcloudapi.net",
            exchange_online="https://outlook.office365.us",
        ),
        suffixes=AzureCloudSuffixes(
            storage_endpoint="core.usgovcloudapi.net",
            storage_sync_endpoint="afs.azure.us",
            keyvault_dns=".vault.usgovcloudapi.net",
            mhsm_dns=".managedhsm.usgovcloudapi.net",
            sql_server_hostname=".database.usgovcloudapi.net",
            mysql_server_endpoint=".mysql.database.usgovcloudapi.net",
            postgresql_server_endpoint=".postgres.database.usgovcloudapi.net",
            mariadb_server_endpoint=".mariadb.database.usgovcloudapi.net",
            acr_login_server_endpoint=".azurecr.us",
            synapse_analytics_endpoint=".dev.azuresynapse.usgovcloudapi.net",
        ),
    )

    AZURE_DOD_CLOUD = AzureCloud(
        "Embedded",
        "AzureUSGovernment",
        "dod",
        endpoints=AzureCloudEndpoints(
            management="https://management.core.usgovcloudapi.net/",
            resource_manager="https://management.usgovcloudapi.net/",
            sql_management="https://management.core.usgovcloudapi.net:8443/",
            batch_resource_id="https://batch.core.usgovcloudapi.net/",
            gallery="https://gallery.usgovcloudapi.net/",
            active_directory="https://login.microsoftonline.us",
            active_directory_resource_id="https://management.core.usgovcloudapi.net/",
            active_directory_graph_resource_id="https://graph.windows.net/",
            microsoft_graph_resource_id="https://dod-graph.microsoft.us/",
            vm_image_alias_doc="https://raw.githubusercontent.com/Azure/azure-rest-api-specs/main/arm-compute/quickstart-templates/aliases.json",  # noqa: E501
            media_resource_id="https://rest.media.usgovcloudapi.net",
            ossrdbms_resource_id="https://ossrdbms-aad.database.usgovcloudapi.net",
            app_insights_resource_id="https://api.applicationinsights.us",
            log_analytics_resource_id="https://api.loganalytics.us",
            app_insights_telemetry_channel_resource_id="https://dc.applicationinsights.us/v2/track",
            synapse_analytics_resource_id="https://dev.azuresynapse.usgovcloudapi.net",
            portal="https://portal.azure.us",
            keyvault="https://vault.usgovcloudapi.net",
            exchange_online="https://outlook-dod.office365.us",
        ),
        suffixes=AzureCloudSuffixes(
            storage_endpoint="core.usgovcloudapi.net",
            storage_sync_endpoint="afs.azure.us",
            keyvault_dns=".vault.usgovcloudapi.net",
            mhsm_dns=".managedhsm.usgovcloudapi.net",
            sql_server_hostname=".database.usgovcloudapi.net",
            mysql_server_endpoint=".mysql.database.usgovcloudapi.net",
            postgresql_server_endpoint=".postgres.database.usgovcloudapi.net",
            mariadb_server_endpoint=".mariadb.database.usgovcloudapi.net",
            acr_login_server_endpoint=".azurecr.us",
            synapse_analytics_endpoint=".dev.azuresynapse.usgovcloudapi.net",
        ),
    )


    AZURE_GERMAN_CLOUD = AzureCloud(
        "Embedded",
        "AzureGermanCloud",
        "de",
        endpoints=AzureCloudEndpoints(
            management="https://management.core.cloudapi.de/",
            resource_manager="https://management.microsoftazure.de",
            sql_management="https://management.core.cloudapi.de:8443/",
            batch_resource_id="https://batch.cloudapi.de/",
            gallery="https://gallery.cloudapi.de/",
            active_directory="https://login.microsoftonline.de",
            active_directory_resource_id="https://management.core.cloudapi.de/",
            active_directory_graph_resource_id="https://graph.cloudapi.de/",
            microsoft_graph_resource_id="https://graph.microsoft.de",
            vm_image_alias_doc="https://raw.githubusercontent.com/Azure/azure-rest-api-specs/main/arm-compute/quickstart-templates/aliases.json",  # noqa: E501
            media_resource_id="https://rest.media.cloudapi.de",
            ossrdbms_resource_id="https://ossrdbms-aad.database.cloudapi.de",
            portal="https://portal.microsoftazure.de",
            keyvault="https://vault.microsoftazure.de",
        ),
        suffixes=AzureCloudSuffixes(
            storage_endpoint="core.cloudapi.de",
            keyvault_dns=".vault.microsoftazure.de",
            mhsm_dns=".managedhsm.microsoftazure.de",
            sql_server_hostname=".database.cloudapi.de",
            mysql_server_endpoint=".mysql.database.cloudapi.de",
            postgresql_server_endpoint=".postgres.database.cloudapi.de",
            mariadb_server_endpoint=".mariadb.database.cloudapi.de",
        ),
    )

    AZURE_CHINA_CLOUD = AzureCloud(
        "Embedded",
        "AzureChinaCloud",
        "cn",
        endpoints=AzureCloudEndpoints(
            management="https://management.core.chinacloudapi.cn/",
            resource_manager="https://management.chinacloudapi.cn",
            sql_management="https://management.core.chinacloudapi.cn:8443/",
            batch_resource_id="https://batch.chinacloudapi.cn/",
            gallery="https://gallery.chinacloudapi.cn/",
            active_directory="https://login.chinacloudapi.cn",
            active_directory_resource_id="https://management.core.chinacloudapi.cn/",
            active_directory_graph_resource_id="https://graph.chinacloudapi.cn/",
            microsoft_graph_resource_id="https://microsoftgraph.chinacloudapi.cn",
            vm_image_alias_doc="https://raw.githubusercontent.com/Azure/azure-rest-api-specs/main/arm-compute/quickstart-templates/aliases.json",  # noqa: E501
            media_resource_id="https://rest.media.chinacloudapi.cn",
            ossrdbms_resource_id="https://ossrdbms-aad.database.chinacloudapi.cn",
            app_insights_resource_id="https://api.applicationinsights.azure.cn",
            log_analytics_resource_id="https://api.loganalytics.azure.cn",
            app_insights_telemetry_channel_resource_id="https://dc.applicationinsights.azure.cn/v2/track",
            synapse_analytics_resource_id="https://dev.azuresynapse.azure.cn",
            portal="https://portal.azure.cn",
            keyvault="https://vault.azure.cn",
            exchange_online="https://partner.outlook.cn",
        ),
        suffixes=AzureCloudSuffixes(
            storage_endpoint="core.chinacloudapi.cn",
            keyvault_dns=".vault.azure.cn",
            mhsm_dns=".managedhsm.azure.cn",
            sql_server_hostname=".database.chinacloudapi.cn",
            mysql_server_endpoint=".mysql.database.chinacloudapi.cn",
            postgresql_server_endpoint=".postgres.database.chinacloudapi.cn",
            mariadb_server_endpoint=".mariadb.database.chinacloudapi.cn",
            acr_login_server_endpoint=".azurecr.cn",
            synapse_analytics_endpoint=".dev.azuresynapse.azure.cn",
        ),
    )


    AZURE_CLOUD_NAME_MAPPING = {
        "Worldwide": "com",
        "Germany": "de",
        "China": "cn",
        "US GCC": "gcc",
        "US GCC-High": "gcc-high",
        "DoD": "dod",
    }

    AZURE_CLOUD_NAME_CUSTOM = "Custom"

    AZURE_CLOUDS = {
        "com": AZURE_WORLDWIDE_CLOUD,
        "gcc": AZURE_US_GCC_CLOUD,
        "gcc-high": AZURE_US_GCC_HIGH_CLOUD,
        "dod": AZURE_DOD_CLOUD,
        "de": AZURE_GERMAN_CLOUD,
        "cn": AZURE_CHINA_CLOUD,
    }


    class AzureCloudNames:
        WORLDWIDE = "com"
        GERMANY = "de"
        CHINA = "cn"
        US_GCC = "gcc"
        US_GCC_HIGH = "gcc-high"
        DOD = "dod"
        CUSTOM = "custom"


    def create_custom_azure_cloud(
        origin: str,
        name: str | None = None,
        abbreviation: str | None = None,
        defaults: AzureCloud | None = None,
        endpoints: dict | None = None,
        suffixes: dict | None = None,
    ):
        defaults = defaults or AzureCloud(origin, name, abbreviation)
        endpoints = endpoints or {}
        suffixes = suffixes or {}
        return AzureCloud(
            origin,
            name or defaults.name,
            abbreviation or defaults.abbreviation,
            endpoints=AzureCloudEndpoints(
                management=endpoints.get("management", defaults.endpoints.management),
                resource_manager=endpoints.get("resource_manager", defaults.endpoints.resource_manager),
                sql_management=endpoints.get("sql_management", defaults.endpoints.sql_management),
                batch_resource_id=endpoints.get("batch_resource_id", defaults.endpoints.batch_resource_id),
                gallery=endpoints.get("gallery", defaults.endpoints.gallery),
                active_directory=endpoints.get("active_directory", defaults.endpoints.active_directory),
                active_directory_resource_id=endpoints.get(
                    "active_directory_resource_id", defaults.endpoints.active_directory_resource_id
                ),
                active_directory_graph_resource_id=endpoints.get(
                    "active_directory_graph_resource_id", defaults.endpoints.active_directory_graph_resource_id
                ),
                microsoft_graph_resource_id=endpoints.get(
                    "microsoft_graph_resource_id", defaults.endpoints.microsoft_graph_resource_id
                ),
                active_directory_data_lake_resource_id=endpoints.get(
                    "active_directory_data_lake_resource_id", defaults.endpoints.active_directory_data_lake_resource_id
                ),
                vm_image_alias_doc=endpoints.get("vm_image_alias_doc", defaults.endpoints.vm_image_alias_doc),
                media_resource_id=endpoints.get("media_resource_id", defaults.endpoints.media_resource_id),
                ossrdbms_resource_id=endpoints.get("ossrdbms_resource_id", defaults.endpoints.ossrdbms_resource_id),
                app_insights_resource_id=endpoints.get("app_insights_resource_id", defaults.endpoints.app_insights_resource_id),
                log_analytics_resource_id=endpoints.get("log_analytics_resource_id", defaults.endpoints.log_analytics_resource_id),
                app_insights_telemetry_channel_resource_id=endpoints.get(
                    "app_insights_telemetry_channel_resource_id", defaults.endpoints.app_insights_telemetry_channel_resource_id
                ),
                synapse_analytics_resource_id=endpoints.get(
                    "synapse_analytics_resource_id", defaults.endpoints.synapse_analytics_resource_id
                ),
                attestation_resource_id=endpoints.get("attestation_resource_id", defaults.endpoints.attestation_resource_id),
                portal=endpoints.get("portal", defaults.endpoints.portal),
                keyvault=endpoints.get("keyvault", defaults.endpoints.keyvault),
            ),
            suffixes=AzureCloudSuffixes(
                storage_endpoint=suffixes.get("storage_endpoint", defaults.suffixes.storage_endpoint),
                storage_sync_endpoint=suffixes.get("storage_sync_endpoint", defaults.suffixes.storage_sync_endpoint),
                keyvault_dns=suffixes.get("keyvault_dns", defaults.suffixes.keyvault_dns),
                mhsm_dns=suffixes.get("mhsm_dns", defaults.suffixes.mhsm_dns),
                sql_server_hostname=suffixes.get("sql_server_hostname", defaults.suffixes.sql_server_hostname),
                mysql_server_endpoint=suffixes.get("mysql_server_endpoint", defaults.suffixes.mysql_server_endpoint),
                postgresql_server_endpoint=suffixes.get("postgresql_server_endpoint", defaults.suffixes.postgresql_server_endpoint),
                mariadb_server_endpoint=suffixes.get("mariadb_server_endpoint", defaults.suffixes.mariadb_server_endpoint),
                azure_datalake_store_file_system_endpoint=suffixes.get(
                    "azure_datalake_store_file_system_endpoint", defaults.suffixes.azure_datalake_store_file_system_endpoint
                ),
                azure_datalake_analytics_catalog_and_job_endpoint=suffixes.get(
                    "azure_datalake_analytics_catalog_and_job_endpoint",
                    defaults.suffixes.azure_datalake_analytics_catalog_and_job_endpoint,
                ),
                acr_login_server_endpoint=suffixes.get("acr_login_server_endpoint", defaults.suffixes.acr_login_server_endpoint),
                synapse_analytics_endpoint=suffixes.get("synapse_analytics_endpoint", defaults.suffixes.synapse_analytics_endpoint),
                attestation_endpoint=suffixes.get("attestation_endpoint", defaults.suffixes.attestation_endpoint),
            ),
        )


    def microsoft_defender_for_endpoint_get_base_url(endpoint_type, url, is_gcc=None):
        # Backward compatible argument parsing, preserve the url and is_gcc functionality if provided, otherwise use endpoint_type.
        log_message_append = ""
        if is_gcc:  # Backward compatible.
            endpoint_type = "US GCC"
            log_message_append = f" ,Overriding endpoint to {endpoint_type}, backward compatible."
        elif (endpoint_type == MICROSOFT_DEFENDER_FOR_ENDPOINT_TYPE_CUSTOM or not endpoint_type) and not url:
            # When the integration was configured before our Azure Cloud support, the value will be None.
            if endpoint_type == MICROSOFT_DEFENDER_FOR_ENDPOINT_TYPE_CUSTOM:
                raise DemistoException("Endpoint type is set to 'Custom' but no URL was provided.")
            raise DemistoException("'Endpoint Type' is not set and no URL was provided.")
        endpoint_type = MICROSOFT_DEFENDER_FOR_ENDPOINT_TYPE.get(endpoint_type, "com")
        url = url or MICROSOFT_DEFENDER_FOR_ENDPOINT_API[endpoint_type]
        demisto.info(f"Using url:{url}, endpoint type:{endpoint_type}{log_message_append}")
        return endpoint_type, url


    def get_azure_cloud(params, integration_name):
        azure_cloud_arg = params.get("azure_cloud")
        if not azure_cloud_arg or azure_cloud_arg == AZURE_CLOUD_NAME_CUSTOM:
            # Backward compatibility before the azure cloud settings.
            if "server_url" in params:
                return create_custom_azure_cloud(
                    integration_name,
                    defaults=AZURE_WORLDWIDE_CLOUD,
                    endpoints={"resource_manager": params.get("server_url") or "https://management.azure.com"},
                )
            if "azure_ad_endpoint" in params:
                return create_custom_azure_cloud(
                    integration_name,
                    defaults=AZURE_WORLDWIDE_CLOUD,
                    endpoints={"active_directory": params.get("azure_ad_endpoint") or "https://login.microsoftonline.com"},
                )
            # in multiple Graph integrations, the url is called 'url' or 'host' instead of 'server_url' and the default url is
            # different.
            if "url" in params or "host" in params:
                return create_custom_azure_cloud(
                    integration_name,
                    defaults=AZURE_WORLDWIDE_CLOUD,
                    endpoints={
                        "microsoft_graph_resource_id": params.get("url") or params.get("host") or "https://graph.microsoft.com"
                    },
                )

        # There is no need for backward compatibility support, as the integration didn't support it to begin with.
        return AZURE_CLOUDS.get(AZURE_CLOUD_NAME_MAPPING.get(azure_cloud_arg), AZURE_WORLDWIDE_CLOUD)  # type: ignore[arg-type]


    class MicrosoftClient(BaseClient):
        def __init__(
            self,
            tenant_id: str = "",
            auth_id: str = "",
            enc_key: str | None = "",
            token_retrieval_url: str = "{endpoint}/{tenant_id}/oauth2/v2.0/token",
            app_name: str = "",
            refresh_token: str = "",
            auth_code: str = "",
            scope: str = "{graph_endpoint}/.default",
            grant_type: str = CLIENT_CREDENTIALS,
            redirect_uri: str = "https://localhost/myapp",
            resource: str | None = "",
            multi_resource: bool = False,
            resources: list[str] = None,
            verify: bool = True,
            self_deployed: bool = False,
            timeout: int | None = None,
            azure_ad_endpoint: str = "{endpoint}",
            azure_cloud: AzureCloud = AZURE_WORLDWIDE_CLOUD,
            endpoint: str = "__NA__",  # Deprecated
            certificate_thumbprint: str | None = None,
            retry_on_rate_limit: bool = False,
            private_key: str | None = None,
            managed_identities_client_id: str | None = None,
            managed_identities_resource_uri: str | None = None,
            base_url: str | None = None,
            command_prefix: str | None = "command_prefix",
            *args,
            **kwargs,
        ):
            """
            Microsoft Client class that implements logic to authenticate with oproxy or self deployed applications.
            It also provides common logic to handle responses from Microsoft.
            Args:
                tenant_id: If self deployed it's the tenant for the app url, otherwise (oproxy) it's the token
                auth_id: If self deployed it's the client id, otherwise (oproxy) it's the auth id and may also
                contain the token url
                enc_key: If self deployed it's the client secret, otherwise (oproxy) it's the encryption key
                refresh_token: The current used refresh token.
                scope: The scope of the application (only if self deployed)
                resource: The resource of the application (only if self deployed)
                multi_resource: Where or not module uses a multiple resources (self-deployed, auth_code grant type only)
                resources: Resources of the application (for multi-resource mode)
                verify: Demisto insecure parameter
                self_deployed: Indicates whether the integration mode is self deployed or oproxy
                timeout: Connection timeout
                azure_ad_endpoint: Custom endpoint to Azure Active Directory URL
                azure_cloud: Azure Cloud.
                certificate_thumbprint: Certificate's thumbprint that's associated to the app
                private_key: Private key of the certificate
                managed_identities_client_id: The Azure Managed Identities client id
                managed_identities_resource_uri: The resource uri to get token for by Azure Managed Identities
                retry_on_rate_limit: If the http request returns with a 429 - Rate limit reached response,
                                     retry the request using a scheduled command.
                base_url: Optionally override the calculated Azure endpoint, used for self-deployed and backward-compatibility with
                          integration that supported national cloud before the *azure_cloud* parameter.
                command_prefix: The prefix for all integration commands.
            """
            self.command_prefix = command_prefix
            demisto.debug(f"Initializing MicrosoftClient with: {endpoint=} | {azure_cloud.abbreviation}")
            if endpoint != "__NA__":
                # Backward compatible.
                self.azure_cloud = AZURE_CLOUDS.get(endpoint, AZURE_WORLDWIDE_CLOUD)
            else:
                self.azure_cloud = azure_cloud

            super().__init__(*args, verify=verify, base_url=base_url, **kwargs)  # type: ignore[misc]

            self.retry_on_rate_limit = retry_on_rate_limit
            if retry_on_rate_limit and (429 not in self._ok_codes):
                self._ok_codes = self._ok_codes + (429,)
            if not self_deployed:
                auth_id_and_token_retrieval_url = auth_id.split("@")
                auth_id = auth_id_and_token_retrieval_url[0]
                if len(auth_id_and_token_retrieval_url) != 2:
                    self.token_retrieval_url = "https://oproxy.demisto.ninja/obtain-token"  # guardrails-disable-line
                else:
                    self.token_retrieval_url = auth_id_and_token_retrieval_url[1]

                self.app_name = app_name
                self.auth_id = auth_id
                self.enc_key = enc_key
                self.refresh_token = refresh_token

            else:
                self.token_retrieval_url = token_retrieval_url.format(
                    tenant_id=tenant_id, endpoint=self.azure_cloud.endpoints.active_directory.rstrip("/")
                )
                self.client_id = auth_id
                self.client_secret = enc_key
                self.auth_code = auth_code
                self.grant_type = grant_type
                self.resource = resource
                self.scope = scope.format(graph_endpoint=self.azure_cloud.endpoints.microsoft_graph_resource_id.rstrip("/"))
                self.redirect_uri = redirect_uri
                if certificate_thumbprint and private_key:
                    try:
                        import msal  # pylint: disable=E0401

                        self.jwt = msal.oauth2cli.assertion.JwtAssertionCreator(
                            private_key, "RS256", certificate_thumbprint
                        ).create_normal_assertion(audience=self.token_retrieval_url, issuer=self.client_id)
                    except ModuleNotFoundError:
                        raise DemistoException("Unable to use certificate authentication because `msal` is missing.")
                else:
                    self.jwt = None

            self.tenant_id = tenant_id
            self.auth_type = SELF_DEPLOYED_AUTH_TYPE if self_deployed else OPROXY_AUTH_TYPE
            self.verify = verify
            self.azure_ad_endpoint = azure_ad_endpoint.format(endpoint=self.azure_cloud.endpoints.active_directory.rstrip("/"))
            self.timeout = timeout  # type: ignore

            self.multi_resource = multi_resource
            if self.multi_resource:
                self.resources = resources if resources else []
                self.resource_to_access_token: dict[str, str] = {}

            # for Azure Managed Identities purpose
            self.managed_identities_client_id = managed_identities_client_id
            self.managed_identities_resource_uri = managed_identities_resource_uri

        @staticmethod
        def is_command_executed_from_integration():
            ctx = demisto.callingContext.get("context", {})
            executed_commands = ctx.get("ExecutedCommands", [{"moduleBrand": "Scripts"}])

            if executed_commands:
                return executed_commands[0].get("moduleBrand", "") != "Scripts"

            return True

        def http_request(
            self,
            *args,
            resp_type="json",
            headers=None,
            return_empty_response=False,
            scope: str | None = None,
            resource: str = "",
            overwrite_rate_limit_retry=False,
            **kwargs,
        ):
            """
            Overrides Base client request function, retrieves and adds to headers access token before sending the request.

            Args:
                resp_type: Type of response to return. will be ignored if `return_empty_response` is True.
                headers: Headers to add to the request.
                return_empty_response: Return the response itself if the return_code is 206.
                scope: A scope to request. Currently, will work only with self-deployed app.
                resource (str): The resource identifier for which the generated token will have access to.
                overwrite_rate_limit_retry : Skip rate limit retry
            Returns:
                Response from api according to resp_type. The default is `json` (dict or list).
            """
            if "ok_codes" not in kwargs and not self._ok_codes:
                kwargs["ok_codes"] = (200, 201, 202, 204, 206, 404)
            token = self.get_access_token(resource=resource, scope=scope)
            default_headers = {"Authorization": f"Bearer {token}", "Content-Type": "application/json", "Accept": "application/json"}

            if headers:
                default_headers |= headers

            if self.timeout:
                kwargs["timeout"] = self.timeout

            should_http_retry_on_rate_limit = self.retry_on_rate_limit and not overwrite_rate_limit_retry
            if should_http_retry_on_rate_limit and not kwargs.get("error_handler"):
                kwargs["error_handler"] = self.handle_error_with_metrics

            response = super()._http_request(  # type: ignore[misc]
                *args, resp_type="response", headers=default_headers, **kwargs
            )

            if should_http_retry_on_rate_limit and MicrosoftClient.is_command_executed_from_integration():
                MicrosoftClient.create_api_metrics(response.status_code)
            # 206 indicates Partial Content, reason will be in the warning header.
            # In that case, logs with the warning header will be written.
            if response.status_code == 206:
                demisto.debug(str(response.headers))
            is_response_empty_and_successful = response.status_code == 204
            if is_response_empty_and_successful and return_empty_response:
                return response

            # Handle 404 errors instead of raising them as exceptions:
            if response.status_code == 404:
                try:
                    error_message = response.json()
                except Exception:
                    error_message = "Not Found - 404 Response"
                raise NotFoundError(error_message)

            if should_http_retry_on_rate_limit and response.status_code == 429 and is_demisto_version_ge("6.2.0"):
                command_args = demisto.args()
                ran_once_flag = command_args.get("ran_once_flag")
                demisto.info(f"429 MS rate limit for command {demisto.command()}, where ran_once_flag is {ran_once_flag}")
                # We want to retry on rate limit only once
                if ran_once_flag:
                    try:
                        error_message = response.json()
                    except Exception:
                        error_message = "Rate limit reached on retry - 429 Response"
                    demisto.info(f"Error in retry for MS rate limit - {error_message}")
                    raise DemistoException(error_message)

                else:
                    demisto.info(f"Scheduling command {demisto.command()}")
                    command_args["ran_once_flag"] = True
                    return_results(MicrosoftClient.run_retry_on_rate_limit(command_args))
                    sys.exit(0)

            try:
                if resp_type == "json":
                    return response.json()
                if resp_type == "text":
                    return response.text
                if resp_type == "content":
                    return response.content
                if resp_type == "xml":
                    try:
                        import defusedxml.ElementTree as defused_ET

                        defused_ET.fromstring(response.text)
                    except ImportError:
                        demisto.debug("defused_ET is not supported, using ET instead.")
                        ET.fromstring(response.text)
                return response
            except ValueError as exception:
                raise DemistoException(f"Failed to parse json object from response: {response.content}", exception)

        def get_access_token(self, resource: str = "", scope: str | None = None) -> str:
            """
            Obtains access and refresh token from oproxy server or just a token from a self deployed app.
            Access token is used and stored in the integration context
            until expiration time. After expiration, new refresh token and access token are obtained and stored in the
            integration context.

            Args:
                resource: The resource identifier for which the generated token will have access to.
                scope: A scope to get instead of the default on the API.

            Returns:
                str: Access token that will be added to authorization header.
            """
            integration_context = get_integration_context()
            refresh_token = integration_context.get("current_refresh_token", "")
            # Set keywords. Default without the scope prefix.
            access_token_keyword = f"{scope}_access_token" if scope else "access_token"
            valid_until_keyword = f"{scope}_valid_until" if scope else "valid_until"

            access_token = integration_context.get(resource) if self.multi_resource else integration_context.get(access_token_keyword)

            valid_until = integration_context.get(valid_until_keyword)

            if access_token and valid_until and self.epoch_seconds() < valid_until:
                return access_token

            if self.auth_type == OPROXY_AUTH_TYPE:
                if self.multi_resource:
                    expires_in = None
                    for resource_str in self.resources:
                        access_token, current_expires_in, refresh_token = self._oproxy_authorize(resource_str)
                        self.resource_to_access_token[resource_str] = access_token
                        self.refresh_token = refresh_token
                        expires_in = current_expires_in if expires_in is None else min(expires_in, current_expires_in)  # type: ignore[call-overload]
                    if expires_in is None:
                        raise DemistoException("No resource was provided to get access token from")
                else:
                    access_token, expires_in, refresh_token = self._oproxy_authorize(scope=scope)

            else:
                access_token, expires_in, refresh_token = self._get_self_deployed_token(refresh_token, scope, integration_context)
            time_now = self.epoch_seconds()
            time_buffer = 5  # seconds by which to shorten the validity period
            if expires_in - time_buffer > 0:
                # err on the side of caution with a slightly shorter access token validity period
                expires_in = expires_in - time_buffer
            valid_until = time_now + expires_in
            integration_context.update(
                {access_token_keyword: access_token, valid_until_keyword: valid_until, "current_refresh_token": refresh_token}
            )

            # Add resource access token mapping
            if self.multi_resource:
                integration_context.update(self.resource_to_access_token)

            set_integration_context(integration_context)
            demisto.debug("Set integration context successfully.")

            if self.multi_resource:
                return self.resource_to_access_token[resource]

            return access_token

        def _raise_authentication_error(self, oproxy_response: requests.Response):
            """
            Raises an exception for authentication error with the Oproxy server.
            Args:
                oproxy_response: Raw response from the Oproxy server to parse.
            """
            msg = "Error in Microsoft authorization."
            try:
                demisto.info(
                    f"Authentication failure from server: {oproxy_response.status_code} {oproxy_response.reason} "
                    f"{oproxy_response.text}"
                )
                msg += f" Status: {oproxy_response.status_code},"
                search_microsoft_response = re.search(r"{.*}", oproxy_response.text)
                microsoft_response = (
                    self.extract_microsoft_error(json.loads(search_microsoft_response.group())) if search_microsoft_response else ""
                )
                err_str = microsoft_response or oproxy_response.text
                if err_str:
                    msg += f" body: {err_str}"
                err_response = oproxy_response.json()
                server_msg = err_response.get("message", "") or f'{err_response.get("title", "")}. {err_response.get("detail", "")}'
                if server_msg:
                    msg += f" Server message: {server_msg}"
            except Exception as ex:
                demisto.error(f"Failed parsing error response - Exception: {ex}")
            raise Exception(msg)

        def _oproxy_authorize_build_request(
            self, headers: dict[str, str], content: str, scope: str | None = None, resource: str = ""
        ) -> requests.Response:
            """
            Build the Post request sent to the Oproxy server.
            Args:
                headers: The headers of the request.
                content: The content for the request (usually contains the refresh token).
                scope: A scope to add to the request. Do not use it.
                resource: Resource to get.

            Returns: The response from the Oproxy server.

            """
            return requests.post(
                self.token_retrieval_url,
                headers=headers,
                json={
                    "app_name": self.app_name,
                    "registration_id": self.auth_id,
                    "encrypted_token": self.get_encrypted(content, self.enc_key),
                    "scope": scope,
                    "resource": resource,
                },
                verify=self.verify,
            )

        def _oproxy_authorize(self, resource: str = "", scope: str | None = None) -> tuple[str, int, str]:
            """
            Gets a token by authorizing with oproxy.
            Args:
                scope: A scope to add to the request. Do not use it.
                resource: Resource to get.
            Returns:
                tuple: An access token, its expiry and refresh token.
            """
            content = self.refresh_token or self.tenant_id
            headers = self._add_info_headers()
            context = get_integration_context()
            next_request_time = context.get("next_request_time", 0.0)
            delay_request_counter = min(int(context.get("delay_request_counter", 1)), MAX_DELAY_REQUEST_COUNTER)

            should_delay_request(next_request_time)
            oproxy_response = self._oproxy_authorize_build_request(headers, content, scope, resource)

            if not oproxy_response.ok:
                next_request_time = calculate_next_request_time(delay_request_counter=delay_request_counter)
                set_retry_mechanism_arguments(
                    next_request_time=next_request_time, delay_request_counter=delay_request_counter, context=context
                )
                self._raise_authentication_error(oproxy_response)

            # In case of success, reset the retry mechanism arguments.
            set_retry_mechanism_arguments(context=context)
            # Oproxy authentication succeeded
            try:
                gcloud_function_exec_id = oproxy_response.headers.get("Function-Execution-Id")
                demisto.info(f"Google Cloud Function Execution ID: {gcloud_function_exec_id}")
                parsed_response = oproxy_response.json()
            except ValueError:
                raise Exception(
                    "There was a problem in retrieving an updated access token.\n"
                    "The response from the Oproxy server did not contain the expected content."
                )

            return (
                parsed_response.get("access_token", ""),
                parsed_response.get("expires_in", 3595),
                parsed_response.get("refresh_token", ""),
            )

        def _get_self_deployed_token(
            self, refresh_token: str = "", scope: str | None = None, integration_context: dict | None = None
        ) -> tuple[str, int, str]:
            if self.managed_identities_client_id:
                if not self.multi_resource:
                    return self._get_managed_identities_token()

                expires_in = -1  # init variable as an int
                for resource in self.resources:
                    access_token, expires_in, refresh_token = self._get_managed_identities_token(resource=resource)
                    self.resource_to_access_token[resource] = access_token
                return "", expires_in, refresh_token

            if self.grant_type == AUTHORIZATION_CODE:
                if not self.multi_resource:
                    return self._get_self_deployed_token_auth_code(refresh_token, scope=scope)
                expires_in = -1  # init variable as an int
                for resource in self.resources:
                    access_token, expires_in, refresh_token = self._get_self_deployed_token_auth_code(refresh_token, resource)
                    self.resource_to_access_token[resource] = access_token

                return "", expires_in, refresh_token
            elif self.grant_type == DEVICE_CODE:
                return self._get_token_device_code(refresh_token, scope, integration_context)
            else:
                # by default, grant_type is CLIENT_CREDENTIALS
                if self.multi_resource:
                    expires_in = -1  # init variable as an int
                    for resource in self.resources:
                        access_token, expires_in, refresh_token = self._get_self_deployed_token_client_credentials(resource=resource)
                        self.resource_to_access_token[resource] = access_token
                    return "", expires_in, refresh_token
                return self._get_self_deployed_token_client_credentials(scope=scope)

        def _get_self_deployed_token_client_credentials(
            self, scope: str | None = None, resource: str | None = None
        ) -> tuple[str, int, str]:
            """
            Gets a token by authorizing a self deployed Azure application in client credentials grant type.

            Args:
                scope: A scope to add to the headers. Else will get self.scope.
                resource: A resource to add to the headers. Else will get self.resource.
            Returns:
                tuple: An access token and its expiry.
            """
            data = {"client_id": self.client_id, "client_secret": self.client_secret, "grant_type": CLIENT_CREDENTIALS}

            if self.jwt:
                data.pop("client_secret", None)
                data["client_assertion_type"] = "urn:ietf:params:oauth:client-assertion-type:jwt-bearer"
                data["client_assertion"] = self.jwt

            # Set scope.
            if self.scope or scope:
                data["scope"] = scope or self.scope

            if self.resource or resource:
                data["resource"] = resource or self.resource  # type: ignore

            response_json: dict = {}
            try:
                response = requests.post(self.token_retrieval_url, data, verify=self.verify)
                if response.status_code not in {200, 201}:
                    return_error(
                        f"Error in Microsoft authorization. Status: {response.status_code}, body: {self.error_parser(response)}"
                    )
                response_json = response.json()
            except Exception as e:
                return_error(f"Error in Microsoft authorization: {e!s}")

            access_token = response_json.get("access_token", "")
            expires_in = int(response_json.get("expires_in", 3595))

            return access_token, expires_in, ""

        def _get_self_deployed_token_auth_code(
            self, refresh_token: str = "", resource: str = "", scope: str | None = None
        ) -> tuple[str, int, str]:
            """
            Gets a token by authorizing a self deployed Azure application.
            Returns:
                tuple: An access token, its expiry and refresh token.
            """
            data = assign_params(
                client_id=self.client_id,
                client_secret=self.client_secret,
                resource=resource if resource else self.resource,
                redirect_uri=self.redirect_uri,
            )

            if self.jwt:
                data.pop("client_secret", None)
                data["client_assertion_type"] = "urn:ietf:params:oauth:client-assertion-type:jwt-bearer"
                data["client_assertion"] = self.jwt

            if scope:
                data["scope"] = scope

            refresh_token = refresh_token or self._get_refresh_token_from_auth_code_param()
            if refresh_token:
                data["grant_type"] = REFRESH_TOKEN
                data["refresh_token"] = refresh_token
            else:
                if SESSION_STATE in self.auth_code:
                    raise ValueError(
                        "Malformed auth_code parameter: Please copy the auth code from the redirected uri "
                        'without any additional info and without the "session_state" query parameter.'
                    )
                data["grant_type"] = AUTHORIZATION_CODE
                data["code"] = self.auth_code

            response_json: dict = {}
            try:
                response = requests.post(self.token_retrieval_url, data, verify=self.verify)
                if response.status_code not in {200, 201}:
                    return_error(
                        f"Error in Microsoft authorization. Status: {response.status_code}, body: {self.error_parser(response)}"
                    )
                response_json = response.json()
            except Exception as e:
                return_error(f"Error in Microsoft authorization: {e!s}")

            access_token = response_json.get("access_token", "")
            expires_in = int(response_json.get("expires_in", 3595))
            refresh_token = response_json.get("refresh_token", "")

            return access_token, expires_in, refresh_token

        def _get_managed_identities_token(self, resource=None):
            """
            Gets a token based on the Azure Managed Identities mechanism
            in case user was configured the Azure VM and the other Azure resource correctly
            """
            try:
                # system assigned are restricted to one per resource and is tied to the lifecycle of the Azure resource
                # see https://learn.microsoft.com/en-us/azure/active-directory/managed-identities-azure-resources/overview
                use_system_assigned = self.managed_identities_client_id == MANAGED_IDENTITIES_SYSTEM_ASSIGNED
                resource = resource or self.managed_identities_resource_uri

                demisto.debug("try to get Managed Identities token")

                params = {"resource": resource}
                if not use_system_assigned:
                    params["client_id"] = self.managed_identities_client_id

                response_json = requests.get(MANAGED_IDENTITIES_TOKEN_URL, params=params, headers={"Metadata": "True"}).json()
                access_token = response_json.get("access_token")
                expires_in = int(response_json.get("expires_in", 3595))
                if access_token:
                    return access_token, expires_in, ""

                err = response_json.get("error_description")
            except Exception as e:
                err = f"{e!s}"

            return_error(f"Error in Microsoft authorization with Azure Managed Identities: {err}")
            return None

        def _get_token_device_code(
            self, refresh_token: str = "", scope: str | None = None, integration_context: dict | None = None
        ) -> tuple[str, int, str]:
            """
            Gets a token by authorizing a self deployed Azure application.

            Returns:
                tuple: An access token, its expiry and refresh token.
            """
            data = {"client_id": self.client_id, "scope": scope}

            if refresh_token:
                data["grant_type"] = REFRESH_TOKEN
                data["refresh_token"] = refresh_token
            else:
                data["grant_type"] = DEVICE_CODE
                if integration_context:
                    data["code"] = integration_context.get("device_code")

            response_json: dict = {}
            try:
                response = requests.post(self.token_retrieval_url, data, verify=self.verify)
                if response.status_code not in {200, 201}:
                    return_error(
                        f"Error in Microsoft authorization. Status: {response.status_code}, body: {self.error_parser(response)}"
                    )
                response_json = response.json()
            except Exception as e:
                return_error(f"Error in Microsoft authorization: {e!s}")

            access_token = response_json.get("access_token", "")
            expires_in = int(response_json.get("expires_in", 3595))
            refresh_token = response_json.get("refresh_token", "")

            return access_token, expires_in, refresh_token

        def _get_refresh_token_from_auth_code_param(self) -> str:
            refresh_prefix = "refresh_token:"
            if self.auth_code.startswith(refresh_prefix):  # for testing we allow setting the refresh token directly
                demisto.debug("Using refresh token set as auth_code")
                return self.auth_code[len(refresh_prefix) :]
            return ""

        @staticmethod
        def run_retry_on_rate_limit(args_for_next_run: dict):
            return CommandResults(
                readable_output="Rate limit reached, rerunning the command in 1 min",
                scheduled_command=ScheduledCommand(
                    command=demisto.command(), next_run_in_seconds=60, args=args_for_next_run, timeout_in_seconds=900
                ),
            )

        def handle_error_with_metrics(self, res):
            MicrosoftClient.create_api_metrics(res.status_code)
            self.client_error_handler(res)

        @staticmethod
        def create_api_metrics(status_code):
            execution_metrics = ExecutionMetrics()
            ok_codes = (200, 201, 202, 204, 206)

            if not execution_metrics.is_supported() or demisto.command() in ["test-module", "fetch-incidents"]:
                return
            if status_code == 429:
                execution_metrics.quota_error += 1
            elif status_code in ok_codes:
                execution_metrics.success += 1
            else:
                execution_metrics.general_error += 1
            return_results(execution_metrics.metrics)

        def error_parser(self, error: requests.Response) -> str:
            """

            Args:
                error (requests.Response): response with error

            Returns:
                str: string of error

            """
            try:
                response = error.json()
                demisto.error(str(response))
                err_str = self.extract_microsoft_error(response)
                if err_str:
                    return err_str
                # If no error message
                raise ValueError
            except ValueError:
                return error.text

        def extract_microsoft_error(self, response: dict) -> str | None:
            """
            Extracts the Microsoft error message from the JSON response.

            Args:
                response (dict): JSON response received from the microsoft server.

            Returns:
                str or None: Extracted Microsoft error message if found, otherwise returns None.
            """
            inner_error = response.get("error", {})
            error_codes = response.get("error_codes", [""])
            err_desc = response.get("error_description", "")

            if isinstance(inner_error, dict):
                err_str = f"{inner_error.get('code')}: {inner_error.get('message')}"
            else:
                err_str = inner_error
                re_search = re.search(REGEX_SEARCH_ERROR_DESC, err_desc)
                err_str += f". \n{re_search['desc']}" if re_search else ""

            if err_str:
                if set(error_codes).issubset(TOKEN_EXPIRED_ERROR_CODES):
                    err_str += (
                        f"\nYou can run the ***{self.command_prefix}-auth-reset*** command to reset the authentication process."
                    )
                return err_str
            # If no error message
            return None

        @staticmethod
        def epoch_seconds(d: datetime = None) -> int:
            """
            Return the number of seconds for given date. If no date, return current.

            Args:
                d (datetime): timestamp
            Returns:
                 int: timestamp in epoch
            """
            if not d:
                d = MicrosoftClient._get_utcnow()
            return int((d - MicrosoftClient._get_utc_from_timestamp(0)).total_seconds())

        @staticmethod
        def _get_utcnow() -> datetime:
            return datetime.utcnow()

        @staticmethod
        def _get_utc_from_timestamp(_time) -> datetime:
            return datetime.utcfromtimestamp(_time)

        @staticmethod
        def get_encrypted(content: str, key: str | None) -> str:
            """
            Encrypts content with encryption key.
            Args:
                content: Content to encrypt
                key: encryption key from oproxy

            Returns:
                timestamp: Encrypted content
            """

            def create_nonce():
                return os.urandom(12)

            def encrypt(string, enc_key):
                """
                Encrypts string input with encryption key.
                Args:
                    string: String to encrypt
                    enc_key: Encryption key

                Returns:
                    bytes: Encrypted value
                """
                # String to bytes
                try:
                    enc_key = base64.b64decode(enc_key)
                except Exception as err:
                    return_error(
                        f"Error in Microsoft authorization: {err!s} Please check authentication related parameters.",
                        error=traceback.format_exc(),
                    )

                # Create key
                aes_gcm = AESGCM(enc_key)
                # Create nonce
                nonce = create_nonce()
                # Create ciphered data
                data = string.encode()
                ct = aes_gcm.encrypt(nonce, data, None)
                return base64.b64encode(nonce + ct)

            now = MicrosoftClient.epoch_seconds()
            encrypted = encrypt(f"{now}:{content}", key).decode("utf-8")
            return encrypted

        @staticmethod
        def _add_info_headers() -> dict[str, str]:
            # pylint: disable=no-member
            headers = {}
            try:
                headers = get_x_content_info_headers()
            except Exception as e:
                demisto.error(f"Failed getting integration info: {e!s}")

            return headers

        def device_auth_request(self) -> dict:
            response_json = {}
            try:
                response = requests.post(
                    url=f"{self.azure_ad_endpoint}/organizations/oauth2/v2.0/devicecode",
                    data={"client_id": self.client_id, "scope": self.scope},
                    verify=self.verify,
                )
                if not response.ok:
                    return_error(
                        f"Error in Microsoft authorization. Status: {response.status_code}, body: {self.error_parser(response)}"
                    )
                response_json = response.json()
            except Exception as e:
                return_error(f"Error in Microsoft authorization: {e!s}")
            set_integration_context({"device_code": response_json.get("device_code")})
            return response_json

        def start_auth(self, complete_command: str) -> str:
            response = self.device_auth_request()
            message = response.get("message", "")
            re_search = re.search(REGEX_SEARCH_URL, message)
            url = re_search["url"] if re_search else None
            user_code = response.get("user_code")

            return f"""### Authorization instructions
    1. To sign in, use a web browser to open the page [{url}]({url})
    and enter the code **{user_code}** to authenticate.
    2. Run the **{complete_command}** command in the War Room."""


    class NotFoundError(Exception):
        """Exception raised for 404 - Not Found errors.

        Attributes:
            message -- explanation of the error
        """

        def __init__(self, message):
            self.message = message


    def calculate_next_request_time(delay_request_counter: int) -> float:
        """
        Calculates the next request time based on the delay_request_counter.
        This is an implication of the Moderate Retry Mechanism for the Oproxy requests.
        """
        # The max delay time should be limited to ~60 sec.
        next_request_time = get_current_time() + timedelta(seconds=(2**delay_request_counter))
        return next_request_time.timestamp()


    def set_retry_mechanism_arguments(context: dict, next_request_time: float = 0.0, delay_request_counter: int = 1):
        """
        Sets the next_request_time in the integration context.
        This is an implication of the Moderate Retry Mechanism for the Oproxy requests.
        """
        context = context or {}
        next_counter = delay_request_counter + 1

        context["next_request_time"] = next_request_time
        context["delay_request_counter"] = next_counter
        # Should reset the context retry arguments.
        if next_request_time == 0.0:
            context["delay_request_counter"] = 1
        set_integration_context(context)


    def should_delay_request(next_request_time: float):
        """
        Checks if the request should be delayed based on context variables.
        This is an implication of the Moderate Retry Mechanism for the Oproxy requests.
        """
        now = get_current_time().timestamp()

        # If the next_request_time is 0 or negative, it means that the request should not be delayed because no error has occurred.
        if next_request_time <= 0.0:
            return
        # Checking if the next_request_time has passed.
        if now >= next_request_time:
            return
        raise Exception(f"The request will be delayed until {datetime.fromtimestamp(next_request_time)}")


    def get_azure_managed_identities_client_id(params: dict) -> str | None:
        """
        Extract the Azure Managed Identities from the demisto params

        Args:
            params (dict): the demisto params

        Returns:
            Optional[str]: if the use_managed_identities are True
            the managed_identities_client_id or MANAGED_IDENTITIES_SYSTEM_ASSIGNED
            will return, otherwise - None

        """
        auth_type = params.get("auth_type") or params.get("authentication_type")
        if params and (argToBoolean(params.get("use_managed_identities") or auth_type == "Azure Managed Identities")):
            client_id = params.get("managed_identities_client_id", {}).get("password")
            return client_id or MANAGED_IDENTITIES_SYSTEM_ASSIGNED
        return None


    def generate_login_url(client: MicrosoftClient, login_url: str = "https://login.microsoftonline.com/") -> CommandResults:
        missing = []
        if not client.client_id:
            missing.append("client_id")
        if not client.tenant_id:
            missing.append("tenant_id")
        if not client.scope:
            missing.append("scope")
        if not client.redirect_uri:
            missing.append("redirect_uri")
        if missing:
            raise DemistoException(
                f"Please make sure you entered the Authorization configuration correctly. Missing:{','.join(missing)}"
            )

        login_url = urljoin(
            login_url,
            f'{client.tenant_id}/oauth2/v2.0/authorize?'
            f'response_type=code&scope=offline_access%20{client.scope.replace(" ", "%20")}'
            f'&client_id={client.client_id}&redirect_uri={client.redirect_uri}',
        )

        result_msg = f"""### Authorization instructions
    1. Click on the [login URL]({login_url}) to sign in and grant Cortex XSOAR permissions for your Azure Service Management.
    You will be automatically redirected to a link with the following structure:
    ```REDIRECT_URI?code=AUTH_CODE&session_state=SESSION_STATE```
    2. Copy the `AUTH_CODE` (without the `code=` prefix, and the `session_state` parameter)
    and paste it in your instance configuration under the **Authorization code** parameter.
     """
        return CommandResults(readable_output=result_msg)


    def get_from_args_or_params(args: dict[str, Any], params: dict[str, Any], key: str) -> Any:
        """
        Get a value from args or params, if the value is provided in both args and params, the value from args will be used.
        if the value is not provided in args or params, an exception will be raised.
        this function is used in commands that have a value that can be provided in the instance parameters or in the command,
        e.g in azure-key-vault-delete 'subscription_id' can be provided in the instance parameters or in the command.
        Args:
            args (Dict[str, Any]): Demisto args.
            params (Dict[str, Any]): Demisto params
            key (str): Key to get.
        """
        if value := args.get(key, params.get(key)):
            return value
        else:
            raise Exception(f"No {key} was provided. Please provide a {key} either in the \
    instance configuration or as a command argument.")


    def azure_tag_formatter(arg):
        """
        Formats a tag argument to the Azure format
        Args:
            arg (str): Tag argument as string
        Returns:
            str: Tag argument in Azure format
        """
        try:
            tag = json.loads(arg)
            tag_name = next(iter(tag))
            tag_value = tag[tag_name]
            return f"tagName eq '{tag_name}' and tagValue eq '{tag_value}'"
        except Exception as e:
            raise Exception(
                """Invalid tag format, please use the following format: '{"key_name":"value_name"}'""",
                e,
            ) from e


    def reset_auth() -> CommandResults:
        """
        This command resets the integration context.
        After running the command, a new token/auth-code will need to be given by the user to regenerate the access token.
        :return: Message about resetting the authorization process.
        """
        demisto.debug(f"Reset integration-context, before resetting {get_integration_context()=}")
        set_integration_context({})
        return CommandResults(
            readable_output="Authorization was reset successfully. Please regenerate the credentials, "
            "and then click **Test** to validate the credentials and connection."
        )

    register_module_line('MicrosoftApiModule', 'end', __line__(), wrapper=1)
    ### END GENERATED CODE ###
    from oauthlib.oauth2 import OAuth2Token

    """ Constants """
    INTEGRATION_NAME = get_integration_name()
    FOLDER_ID_LEN = 120

    SUPPORTED_ON_PREM_BUILDS = {
        "2007": EXCHANGE_2007,
        "2010": EXCHANGE_2010,
        "2010_SP2": EXCHANGE_2010_SP2,
        "2013": EXCHANGE_2013,
        "2013_SP1": EXCHANGE_2013_SP1,
        "2016": EXCHANGE_2016,
        "2019": EXCHANGE_2019,
    }

    """ Context Keys """
    ATTACHMENT_ID = "attachmentId"
    ACTION = "action"
    MAILBOX = "mailbox"
    MAILBOX_ID = "mailboxId"
    MOVED_TO_MAILBOX = "movedToMailbox"
    MOVED_TO_FOLDER = "movedToFolder"
    NEW_ITEM_ID = "newItemId"
    MESSAGE_ID = "messageId"
    ITEM_ID = "itemId"
    TARGET_MAILBOX = "receivedBy"
    FOLDER_ID = "id"

    """ Context Paths """
    CONTEXT_UPDATE_ITEM_ATTACHMENT = f".ItemAttachments(val.{ATTACHMENT_ID} == obj.{ATTACHMENT_ID})"
    CONTEXT_UPDATE_FILE_ATTACHMENT = f".FileAttachments(val.{ATTACHMENT_ID} == obj.{ATTACHMENT_ID})"
    CONTEXT_UPDATE_FOLDER = f"EWS.Folders(val.{FOLDER_ID} == obj.{FOLDER_ID})"
    CONTEXT_UPDATE_EWS_ITEM = (
        f"EWS.Items((val.{ITEM_ID} === obj.{ITEM_ID} || "
        f"(val.{MESSAGE_ID} && obj.{MESSAGE_ID} && val.{MESSAGE_ID} === obj.{MESSAGE_ID}))"
        f" && val.{TARGET_MAILBOX} === obj.{TARGET_MAILBOX})"
    )


    class IncidentFilter(str, Enum):
        MODIFIED_FILTER = "modified-time"
        RECEIVED_FILTER = "received-time"


    class CustomDomainOAuth2Credentials(OAuth2AuthorizationCodeCredentials):
        def __init__(self, azure_cloud: AzureCloud, **kwargs):
            self.ad_base_url = azure_cloud.endpoints.active_directory or "https://login.microsoftonline.com"
            self.exchange_online_scope = azure_cloud.endpoints.exchange_online or "https://outlook.office365.com"
            demisto.debug(
                f"Initializing {self.__class__}: {azure_cloud.abbreviation=} | {self.ad_base_url=} | {self.exchange_online_scope}"
            )
            super().__init__(**kwargs)

        @property
        def token_url(self):
            """
            The URL to request tokens from.
            Overrides the token_url property to specify custom token retrieval endpoints for different authority's cloud env.
            """
            # We may not know (or need) the Microsoft tenant ID. If not, use common/ to let Microsoft select the appropriate
            # tenant for the provided authorization code or refresh token.
            return f'{self.ad_base_url}/{self.tenant_id or "common"}/oauth2/v2.0/token'

        @property
        def scope(self):
            """
            The scope we ask for the token to have
            Overrides the scope property to specify custom token retrieval endpoints for different authority's cloud env.
            """
            return [f"{self.exchange_online_scope}/.default"]


    class ProxyAdapter(HTTPAdapter):
        """
        Proxy Adapter used to add PROXY to requests
        """

        def send(self, *args, **kwargs):
            kwargs["proxies"] = handle_proxy()
            return super().send(*args, **kwargs)


    class InsecureSSLAdapter(SSLAdapter):
        """
        Insecure SSL Adapter used to disable SSL verification for requests.
        """

        def __init__(self, *args, **kwargs):
            # Processing before init call
            kwargs.pop("verify", None)
            super().__init__(verify=False, **kwargs)

        def cert_verify(self, conn, url, verify, cert):
            # We're overriding a method, so we have to keep the signature, although verify is unused
            del verify
            super().cert_verify(conn=conn, url=url, verify=False, cert=cert)


    class InsecureProxyAdapter(InsecureSSLAdapter):
        """
        Insecure Proxy Adapter used to add proxy to requests.
        """

        def send(self, *args, **kwargs):
            kwargs["proxies"] = handle_proxy()
            return super().send(*args, **kwargs)


    class GetSearchableMailboxes(EWSService):
        """
        EWSAccountService class used for getting Searchable Mailboxes
        """

        SERVICE_NAME = "GetSearchableMailboxes"
        element_container_name = f"{{{MNS}}}SearchableMailboxes"

        @staticmethod
        def parse_element(element):
            return {
                MAILBOX: element.find(f"{{{TNS}}}PrimarySmtpAddress").text
                if element.find(f"{{{TNS}}}PrimarySmtpAddress") is not None
                else None,
                MAILBOX_ID: element.find(f"{{{TNS}}}ReferenceId").text if element.find(f"{{{TNS}}}ReferenceId") is not None else None,
                "displayName": element.find(f"{{{TNS}}}DisplayName").text
                if element.find(f"{{{TNS}}}DisplayName") is not None
                else None,
                "isExternal": element.find(f"{{{TNS}}}IsExternalMailbox").text
                if element.find(f"{{{TNS}}}IsExternalMailbox") is not None
                else None,
                "externalEmailAddress": element.find(f"{{{TNS}}}ExternalEmailAddress").text
                if element.find(f"{{{TNS}}}ExternalEmailAddress") is not None
                else None,
            }

        def call(self):
            if self.protocol.version.build < EXCHANGE_2013:
                raise NotImplementedError(f"{self.SERVICE_NAME} is only supported for Exchange 2013 servers and later")
            elements = self._get_elements(payload=self.get_payload())
            return [self.parse_element(e) for e in elements if e.find(f"{{{TNS}}}ReferenceId").text]

        def get_payload(self):
            element = create_element(f"m:{self.SERVICE_NAME}")
            return element


    class MarkAsJunk(EWSAccountService):
        """
        EWSAccountService class used for marking items as junk
        """

        SERVICE_NAME = "MarkAsJunk"

        def call(self, item_id, move_item):
            elements = list(self._get_elements(payload=self.get_payload(item_id=item_id, move_item=move_item)))
            for element in elements:
                if isinstance(element, ResponseMessageError):
                    return str(element)
            return "Success"

        def get_payload(self, item_id, move_item):
            junk = create_element(f"m:{self.SERVICE_NAME}", {"IsJunk": "true", "MoveItem": "true" if move_item else "false"})

            items_list = create_element("m:ItemIds")
            item_element = create_element("t:ItemId", {"Id": item_id})
            items_list.append(item_element)
            junk.append(items_list)

            return junk


    class ExpandGroup(EWSService):
        """
        EWSAccountService class used for expanding groups
        """

        SERVICE_NAME = "ExpandDL"
        element_container_name = f"{{{MNS}}}DLExpansion"

        @staticmethod
        def parse_element(element):
            return {
                MAILBOX: element.find(f"{{{TNS}}}EmailAddress").text if element.find(f"{{{TNS}}}EmailAddress") is not None else None,
                "displayName": element.find(f"{{{TNS}}}Name").text if element.find(f"{{{TNS}}}Name") is not None else None,
                "mailboxType": element.find(f"{{{TNS}}}MailboxType").text
                if element.find(f"{{{TNS}}}MailboxType") is not None
                else None,
            }

        def call(self, email_address, recursive_expansion=False):
            if self.protocol.version.build < EXCHANGE_2010:
                raise NotImplementedError(f"{self.SERVICE_NAME} is only supported for Exchange 2010 servers and later")
            try:
                if recursive_expansion == "True":
                    group_members: dict = {}
                    self.expand_group_recursive(email_address, group_members)
                    return list(group_members.values())
                else:
                    return self.expand_group(email_address)

            except ErrorNameResolutionNoResults:
                demisto.results("No results were found.")
                sys.exit()

        def get_payload(self, email_address):
            element = create_element(f"m:{self.SERVICE_NAME}")
            mailbox_element = create_element("m:Mailbox")
            add_xml_child(mailbox_element, "t:EmailAddress", email_address)
            element.append(mailbox_element)
            return element

        def expand_group(self, email_address):
            """
            Expand given group
            :param email_address: email address of the group to expand
            :return: list dict with parsed expanded group data
            """
            elements = self._get_elements(payload=self.get_payload(email_address))
            return [self.parse_element(x) for x in elements]

        def expand_group_recursive(self, email_address, non_dl_emails, dl_emails=None):
            """
            Expand group recursively
            :param email_address: email address of the group to expand
            :param non_dl_emails: non distribution only emails
            :param dl_emails: (Optional) distribution only emails
            :return: Set of dl emails and non dl emails (returned via reference)
            """
            if dl_emails is None:
                dl_emails = set()

            if email_address in non_dl_emails or email_address in dl_emails:
                return

            dl_emails.add(email_address)

            for member in self.expand_group(email_address):
                if member["mailboxType"] == "PublicDL" or member["mailboxType"] == "PrivateDL":
                    self.expand_group_recursive(member.get("mailbox"), non_dl_emails, dl_emails)
                else:
                    if member["mailbox"] not in non_dl_emails:
                        non_dl_emails[member["mailbox"]] = member


    class EWSClient:
        def __init__(
            self,
            client_id: str,
            client_secret: str,
            access_type: str,
            default_target_mailbox: str,
            max_fetch: int,
            ews_server: str = "",
            auth_type: str = "",
            version: str = "",
            folder: str = "Inbox",
            is_public_folder: bool = False,
            request_timeout: int = 120,
            mark_as_read: bool = False,
            incident_filter: IncidentFilter = IncidentFilter.RECEIVED_FILTER,
            azure_cloud: Optional[AzureCloud] = None,
            tenant_id: str = "",
            self_deployed: bool = True,
            log_memory: bool = False,
            app_name: str = "EWS",
            insecure: bool = True,
            proxy: bool = False,
        ):
            """
            Client used to communicate with EWS

            :param client_id: Application client ID
            :param client_secret: Application client secret
            :param access_type: Access type for authentication (delegate or impersonation)
            :param default_target_mailbox: Email address from which to fetch incidents
            :param max_fetch: Max incidents per fetch
            :param ews_server: The EWS Server address.
            :param auth_type: Authentication type (OAUTH2, BASIC, NTLM or DIGEST)
            :param version: Exchange version to use (O365, 2007, 2010, 2010_SP2, 2013, 2013_SP1, 2016, 2019)
            :param folder: Name of the folder from which to fetch incidents
            :param is_public_folder: Public Folder flag
            :param request_timeout: Timeout (in seconds) for HTTP requests to Exchange Server
            :param mark_as_read: Whether to mark fetched incidents as read
            :param incident_filter: The type of time filter to use for incidents (modified or received time)
            :param azure_cloud: (O365 only) The Azure cloud environment for authentication to O365 services
            :param tenant_id: (O365 only) Tenant id used for O365 authentication
            :param self_deployed: (O365 only) Whether the Azure app is self-deployed or part of a managed service
            :param log_memory: Whether to enable memory usage logging for various commands
            :param app_name: The name of the app. (Used for logging purposes only)
            :param insecure: Trust any certificate (not secure)
            :param proxy: Whether to use a proxy for the connection
            """
            if auth_type and auth_type not in (OAUTH2, BASIC, NTLM, DIGEST):
                raise ValueError(f"Invalid auth_type: {auth_type}")

            if ews_server and not version:
                raise ValueError("Version must be provided if EWS Server is specified.")

            BaseProtocol.TIMEOUT = request_timeout  # type: ignore
            self.client_id = client_id
            self.client_secret = client_secret
            self.access_type = access_type.lower()
            self.account_email = default_target_mailbox
            self.ews_server = ews_server
            self.max_fetch = max_fetch
            self.auth_type = auth_type
            self.version = version
            self.folder_name = folder
            self.is_public_folder = is_public_folder
            self.mark_as_read = mark_as_read
            self.incident_filter = incident_filter
            self.azure_cloud = azure_cloud
            self.tenant_id = tenant_id
            self.self_deployed = self_deployed
            self.log_memory = log_memory
            self.app_name = app_name
            self.insecure = insecure
            self.proxy = proxy

            self.auto_discover = not ews_server

            self.config, self.credentials, self.server_build = self._configure_auth()

        def _configure_auth(self) -> tuple[Optional[Configuration], BaseCredentials, Optional[Build]]:
            """
            Prepares the client protocol, credentials and configuration based on the authentication type.

            :return: Configuration and Credentials objects.
            """
            if self.auth_type == OAUTH2:
                return self._configure_oauth()

            return self._configure_onprem()

        def _configure_oauth(self) -> tuple[Configuration, CustomDomainOAuth2Credentials, Build]:
            """
            Prepares the client PROTOCOL, CREDENTIALS and CONFIGURATION

            :return: OAuth 2 Configuration and Credentials
            """
            if self.version != "O365":
                raise ValueError("Error, only the O365 version is supported for OAuth2 authentication.")

            if not self.azure_cloud:
                raise ValueError("Error, failed to get Azure cloud object required for OAuth2 authentication.")

            BaseProtocol.HTTP_ADAPTER_CLS = InsecureProxyAdapter if self.insecure else ProxyAdapter

            self.ms_client = ms_client = MicrosoftClient(
                tenant_id=self.tenant_id,
                auth_id=self.client_id,
                enc_key=self.client_secret,
                app_name=self.app_name,
                base_url=self.ews_server,
                verify=not self.insecure,
                proxy=self.proxy,
                self_deployed=self.self_deployed,
                scope=f"{self.azure_cloud.endpoints.exchange_online}/.default",
                command_prefix="ews",
                azure_cloud=self.azure_cloud,
            )

            access_token = ms_client.get_access_token()
            oauth2_token = OAuth2Token({"access_token": access_token})
            credentials = CustomDomainOAuth2Credentials(
                azure_cloud=self.azure_cloud,
                client_id=self.client_id,
                client_secret=self.client_secret,
                access_token=oauth2_token,
            )
            # need to add identity for protocol OAuth header
            credentials.identity = Identity(upn=self.account_email)
            config = Configuration(
                credentials=credentials,
                auth_type=OAUTH2,
                version=Version(EXCHANGE_O365),
                service_endpoint=f"{self.azure_cloud.endpoints.exchange_online}/EWS/Exchange.asmx",
            )
            return config, credentials, EXCHANGE_O365

        def _configure_onprem(self) -> tuple[Optional[Configuration], Credentials, Optional[Build]]:
            """
            Prepares the client protocol, credentials and configuration based on the authentication type.
            For auto_discovery, the configuration object will be created as needed from the discovered connection parameters.

            :return: Configuration and Credentials objects.
            """
            BaseProtocol.HTTP_ADAPTER_CLS = InsecureSSLAdapter if self.insecure else HTTPAdapter

            if self.auto_discover:
                # Discover the server params using the exchange auto discovery mechanism
                # The discovered config params will be cached in the integration context for subsequent runs
                credentials = Credentials(username=self.client_id, password=self.client_secret)
                self.ews_server, server_build = self.get_autodiscover_server_params(credentials)
                return None, credentials, server_build

            # Check params and set defaults where necessary
            if urlparse(self.ews_server.lower()).hostname == "outlook.office365.com":  # Legacy O365 logic
                if not self.auth_type:
                    self.auth_type = BASIC
                self.version = "2016"

            if not self.auth_type:
                self.auth_type = NTLM

            if not self.version:
                raise DemistoException("Exchange Server Version is required for on-premise Exchange Servers.")

            # Configure the on-prem Exchange Server connection
            credentials = Credentials(username=self.client_id, password=self.client_secret)
            config_args = {"credentials": credentials, "auth_type": self.auth_type, "version": get_on_prem_version(self.version)}
            if "http" in self.ews_server.lower():
                config_args["service_endpoint"] = self.ews_server
            else:
                config_args["server"] = self.ews_server

            return (
                Configuration(**config_args, retry_policy=FaultTolerance(max_wait=60)),
                credentials,
                get_on_prem_build(self.version),
            )

        def get_autodiscover_server_params(self, credentials) -> tuple[str, Optional[Build]]:
            """
            Get the server parameters from the cached autodiscover results and update the integration context.
            If there are no cached results, attempt Account creation with autodiscover to get the parameters, and cache the results.

            :param credentials: Credentials object for authentication

            :return: ews_server, server_build: The discovered Exchange server URL and build version
            """
            context_dict = demisto.getIntegrationContext()
            if context_dict:
                ews_server = get_endpoint_from_context(context_dict)
                server_build = get_build_from_context(context_dict)
            else:
                try:
                    account = Account(
                        primary_smtp_address=self.account_email,
                        autodiscover=True,
                        access_type=self.access_type,
                        credentials=credentials,
                    )
                    ews_server = account.protocol.service_endpoint
                    server_build = account.protocol.version.build
                    demisto.setIntegrationContext(cache_autodiscover_results(context_dict, account))
                except AutoDiscoverFailed:
                    raise DemistoException("Auto discovery failed. Check credentials or configure manually")

            return ews_server, server_build

        def get_protocol(self) -> Protocol:
            """
            Get the EWS protocol with the configured settings.

            :return: The EWS protocol instance.
            """
            if self.auto_discover:
                return self.get_account_autodiscover(self.account_email).protocol

            return Protocol(config=self.config)

        def get_account(self, target_mailbox: Optional[str] = None, time_zone=None) -> Account:
            """
            Request an account from EWS

            :param: target_mailbox: Mailbox associated with the requested account

            :return: exchangelib Account
            """
            if not target_mailbox:
                target_mailbox = self.account_email

            if self.auto_discover:
                return self.get_account_autodiscover(target_mailbox, time_zone)

            return Account(
                primary_smtp_address=target_mailbox,
                autodiscover=False,
                config=self.config,
                access_type=self.access_type,
                default_timezone=time_zone,
            )

        def get_account_autodiscover(self, target_mailbox: str, time_zone=None) -> Account:
            """
            Request an account from EWS using the autodiscovery mechanism

            :param target_mailbox: Mailbox associated with the requested account
            :param time_zone: Timezone associated with the requested account

            :return: exchangelib Account
            """
            original_exc = None
            context_dict = demisto.getIntegrationContext()

            if context_dict:
                try:
                    config_args = get_config_args_from_context(context_dict, self.credentials)
                    account = Account(
                        primary_smtp_address=target_mailbox,
                        autodiscover=False,
                        config=Configuration(**config_args),
                        access_type=self.access_type,
                        default_timezone=time_zone,
                    )
                    account.root.effective_rights.read  # noqa: B018 pylint: disable=E1101
                    return account
                except Exception as e:
                    # fixing flake8 correction where original_exc is assigned but unused
                    original_exc = e

            try:
                account = Account(
                    primary_smtp_address=self.account_email,
                    autodiscover=True,
                    credentials=self.credentials,
                    access_type=self.access_type,
                )
            except AutoDiscoverFailed:
                raise DemistoException("Auto discovery failed. Check credentials or configure manually")

            new_context = cache_autodiscover_results(context_dict, account)
            if new_context == context_dict and original_exc:
                # Autodiscovery returned the same connection params as the cached ones we failed to use
                raise original_exc  # pylint: disable=E0702

            if target_mailbox == self.account_email:
                demisto.setIntegrationContext(new_context)

            return account

        def get_items_from_mailbox(self, account: Optional[Union[Account, str]], item_ids) -> list[Item]:
            """
            Request specific items from a mailbox associated with an account

            :param account: EWS account or target_mailbox associated with that account
            :param item_ids: item_ids of the requested items

            :return: list of exchangelib Items
            """
            # allow user to pass target_mailbox as account
            if not isinstance(account, Account):
                account = self.get_account(account) if isinstance(account, str) else self.get_account(self.account_email)

            if not isinstance(item_ids, list):
                item_ids = [item_ids]

            items = [Item(id=x) for x in item_ids]
            result = list(account.fetch(ids=items))
            result = [x for x in result if not (isinstance(x, ErrorItemNotFound | ErrorInvalidIdMalformed))]
            if len(result) != len(item_ids):
                result_ids = {item.id for item in result}
                missing_ids = set(item_ids) - result_ids
                raise Exception(f"One or more items were not found/malformed. Could not find the following IDs: {missing_ids}")
            return result

        def get_item_from_mailbox(self, account: Optional[Union[Account, str]], item_id) -> Item:
            """
            Request a single item from a mailbox associated with an account

            :param account: EWS account or target_mailbox associated with that account
            :param item_id: item_id of the requested item

            :return: exchangelib Item
            """
            result = self.get_items_from_mailbox(account, [item_id])
            return result[0]

        def get_attachments_for_item(self, item_id, account: Optional[Union[Account, str]], attachment_ids: list = []):
            """
            Request attachments for an item

            :param item_id: item_id of the item to retrieve attachments from
            :param account: EWS account or target_mailbox associated with that account
            :param (Optional) attachment_ids: attachment_ids to retrieve, empty list will get all available attachments

            :return: list of exchangelib Item.attachments
            """
            item = self.get_item_from_mailbox(account, item_id)
            if not item:
                raise DemistoException(f"Message item not found: {item_id}")

            attachments = []
            for attachment in item.attachments or []:
                if attachment is None:
                    continue

                if not attachment_ids or attachment.attachment_id.id in attachment_ids:
                    attachments.append(attachment)

            if attachment_ids and len(attachments) < len(attachment_ids):
                found_ids = {attachment.attachment_id.id for attachment in attachments}
                missing_ids = set(attachment_ids) - found_ids
                raise DemistoException(f"Some attachment ids were not found for the given message id: {missing_ids}")

            return attachments

        def is_default_folder(self, folder_path: str, is_public: Optional[bool] = None) -> bool:
            """
            Check whether the given folder_path is known to be public,
            determined either by the is_public argument, or in the case where folder_path is the
            configured instance folder name and the is_public instance variable is set.

            :param folder_path: folder path to check if is public
            :param is_public: (Optional) if provided, will return this value

            :return: Boolean
            """
            if is_public is not None:
                return is_public

            if folder_path == self.folder_name:
                return self.is_public_folder

            return False

        def get_folder_by_path(self, path: str, account: Optional[Account] = None, is_public: bool = False) -> BaseFolder:
            """
            Retrieve folder by path

            :param path: path of the folder
            :param account: account associated with the requested path
            :param is_public: is the requested folder public

            :return: exchangelib Folder
            """
            if account is None:
                account = self.get_account()
            # handle exchange folder id
            if len(path) == FOLDER_ID_LEN:
                folders_map = account.root._folders_map
                if path in folders_map:
                    return account.root._folders_map[path]

            if is_public:
                folder = account.public_folders_root
            elif self.version == "O365" and path == "AllItems":
                # AllItems is only available on Office365, directly under root
                folder = account.root
            else:
                # Default, contains all of the standard folders (Inbox, Calendar, trash, etc.)
                folder = account.root.tois

            path = path.replace("/", "\\")
            path_parts = path.split("\\")
            for part in path_parts:
                try:
                    demisto.debug(f"resolving {part=} {path_parts=}")
                    folder = folder // part
                except Exception as e:
                    demisto.debug(f"got error {e}")
                    raise ValueError(f"No such folder {path_parts}")
            return folder

        def send_email(self, message: Message):
            """
            Send message using the EWS account associated with this client instance.

            :param message: Message to be sent
            """
            account = self.get_account()
            message.account = account
            message.send_and_save()

        def reply_email(
            self,
            in_reply_to: str,
            to: list[str],
            body: str,
            subject: str,
            bcc: list[str],
            cc: list[str],
            html_body: str | None,
            attachments: list,
            from_mailbox: str | None = None,
            account: Account | None = None,
            handle_inline_image: bool = True,
        ) -> Message:
            """Send a reply email using the EWS account.

            Sends a reply email using the EWS account associated with this client or the provided
            account, based on the provided parameters.

            Args:
                in_reply_to (str): ID of the email to reply to.
                to (list[str]): List of email addresses for the "To" field.
                body (str): Body of the email.
                subject (str): Subject of the email.
                bcc (list[str]): List of 'BCC' email addresses.
                cc (list[str]): List of 'CC' email addresses.
                html_body (str | None): HTML body of the email (overrides body).
                attachments (list): List of attachments to include in the email.
                from_mailbox (str | None, optional): Email address of the sender. Defaults to None.
                account (Account | None, optional): Account for the mailbox containing the email to reply to. Defaults to None.
                handle_inline_image (bool, optional): Whether to process inline images in the HTML body. Defaults to True.

            Returns:
                Message: The sent message.
            """
            demisto.debug(
                f"reply_email: Starting with params: in_reply_to={in_reply_to}, to={to}, subject='{subject}', "
                f"cc={cc}, bcc={bcc}, from_mailbox={from_mailbox}, handle_inline_image={handle_inline_image}, "
                f"has_html_body={html_body is not None}, attachment_count={len(attachments)}"
            )

            if not account:
                demisto.debug("reply_email: No account provided, using default account")
                account = self.get_account()

            item_to_reply_to: Message | ErrorItemNotFound = account.inbox.get(id=in_reply_to)
            if isinstance(item_to_reply_to, ErrorItemNotFound):
                demisto.debug(f"reply_email: Failed to find original message with ID {in_reply_to}")
                raise Exception(item_to_reply_to)

            subject = subject or item_to_reply_to.subject  # type: ignore[assignat]
            html_attachments: list = []
            if html_body and handle_inline_image:
                demisto.debug("reply_email: Processing HTML body for inline images")
                html_body, html_attachments = handle_html(html_body)
                demisto.debug(f"reply_email: Found {len(html_attachments)} inline images in {html_body=}")

            message_body = HTMLBody(html_body) if html_body else body
            reply = item_to_reply_to.create_reply(
                subject="Re: " + subject,
                body=message_body,
                to_recipients=to,
                cc_recipients=cc,
                bcc_recipients=bcc,
                author=from_mailbox,
            )
            reply = reply.save(account.drafts)
            m = account.inbox.get(id=reply.id)  # pylint: disable=E1101

            attachments += html_attachments
            for i, attachment in enumerate(attachments):
                if not isinstance(attachment, FileAttachment):
                    demisto.debug(f"reply_email: Converting attachment {i+1}/{len(attachments)} to FileAttachment")
                    if not attachment.get("cid"):
                        attachment = FileAttachment(name=attachment.get("name"), content=attachment.get("data"))
                    else:
                        attachment = FileAttachment(
                            name=attachment.get("name"),
                            content=attachment.get("data"),
                            is_inline=True,
                            content_id=attachment.get("cid"),
                        )
                m.attach(attachment)
            m.send()

            return m


    def handle_html(html_body) -> tuple[str, List[Dict[str, Any]]]:
        """
        Extract all data-url content from within the html and return as separate attachments.
        Due to security implications, we support only images here
        We might not have Beautiful Soup so just do regex search

        :param html_body: HTML content string

        :return: clean_body, attachments: cleaned HTML body and a list of the extracted attachments.
        """
        attachments = []
        clean_body = ""
        last_index = 0
        for i, m in enumerate(re.finditer(r"<img.+?src=\"(data:(image\/.+?);base64,([a-zA-Z0-9+/=\r\n]+?))\"", html_body, re.I)):
            name = f"image{i}"
            cid = f"{name}@{str(uuid.uuid4())[:8]}_{str(uuid.uuid4())[:8]}"
            attachment = {"data": base64.b64decode(m.group(3)), "name": name}
            attachment["cid"] = cid
            clean_body += html_body[last_index : m.start(1)] + "cid:" + attachment["cid"]
            last_index = m.end() - 1
            new_attachment = FileAttachment(
                name=attachment.get("name"), content=attachment.get("data"), content_id=attachment.get("cid"), is_inline=True
            )
            attachments.append(new_attachment)

        clean_body += html_body[last_index:]
        return clean_body, attachments


    def get_config_args_from_context(context: dict, credentials: BaseCredentials) -> dict:
        """
        Create a configuration obj from the cached autodiscovery results in the provided integration context.

        :param context: the integration context dict
        :param credentials: the credentials

        :return: config: a configuration object for the previously discovered connection params
        """
        auth_type = context["auth_type"]
        api_version = context["api_version"]
        version = Version(get_build_from_context(context), api_version)
        service_endpoint = context["service_endpoint"]

        config_args = {"credentials": credentials, "auth_type": auth_type, "version": version, "service_endpoint": service_endpoint}
        return config_args


    def get_build_from_context(context: dict) -> Build:
        """
        Create a Build object from the cached autodiscovery results in the provided integration context.

        :param context: the integration context dict

        :return: build: a Build object for the previously discovered connection params
        """
        build_params = context["build"].split(".")
        build_params = [int(i) for i in build_params]
        return Build(*build_params)


    def get_endpoint_from_context(context_dict: dict) -> str:
        """
        Get the EWS Server endpoint from the cached autodiscovery results in the provided integration context.

        :param context: the integration context dict

        :return: endpoint: The endpoint from the previously discovered connection params
        """
        return context_dict["service_endpoint"]


    def cache_autodiscover_results(context: dict, account: Account) -> dict:
        """
        Add the autodiscovery results to the integration context for later reuse.

        :param context: the integration context dict
        :param account: the discovered account object

        :return: the updated context
        """
        context["auth_type"] = account.protocol.auth_type
        context["service_endpoint"] = account.protocol.service_endpoint
        context["build"] = str(account.protocol.version.build)
        context["api_version"] = account.protocol.version.api_version

        return context


    def get_on_prem_build(version: str) -> Build:
        """
        Convert a version string to a Build object for supported on-prem Exchange Server versions.

        :param version: The version string (e.g. '2013', '2016', '2019')

        :return: A Build object representing the on-premises Exchange Server build
        """
        if version not in SUPPORTED_ON_PREM_BUILDS:
            supported_versions = "\\".join(list(SUPPORTED_ON_PREM_BUILDS.keys()))
            raise ValueError(f"{version} is not a supported version. Choose one of: {supported_versions}.")

        return SUPPORTED_ON_PREM_BUILDS[version]


    def get_on_prem_version(version: str) -> Version:
        """
        Convert a version string to a Version object for supported on-prem Exchange Server versions.

        :param version: The version string (e.g. '2013', '2016', '2019')

        :return: A Version object representing the on-premises Exchange Server version
        """
        return Version(get_on_prem_build(version))


    # Command functions and helpers


    def is_empty_object(obj) -> bool:
        """
        Checks if the given object is empty.
        :param obj: The object to check.

        :return: True if the object is empty, False otherwise.
        """
        return (obj.__sizeof__() if isinstance(obj, map) else len(obj)) == 0


    def filter_dict_null(d):
        """
        Filters out any none values from a dictionary.
        :param d: The dictionary to filter.

        :return: A new dictionary with all the none values removed.
        """
        if isinstance(d, dict):
            return {k: v for k, v in list(d.items()) if v is not None}
        return d


    def switch_hr_headers(obj, hr_header_changes: dict):
        """
        Will swap keys according to hr_header_changes.
        hr_header_changes: a dict, keys are the old value, value is the new value
        """
        if not isinstance(obj, dict):
            return obj
        obj_copy = obj.copy()
        for old_header, new_header in hr_header_changes.items():
            if old_header in obj:
                obj_copy[new_header] = obj_copy.pop(old_header)
        return obj_copy


    def get_entry_for_object(
        title: str, context_key: str, obj, headers: Optional[list] = None, hr_header_changes: dict = {}, filter_null_values=True
    ) -> CommandResults:
        """
        Create an entry for a given object
        :param title: Title of the human readable
        :param context_key: Context key used for entry context
        :param obj: Object to create entry for
        :param headers: (Optional) headers used in the tableToMarkDown
        :param hr_header_changes: (Optional) a dict to map the header names used in the human readable output
        :param filter_null_values: (Optional) Whether to filter null values from the object or not (O365 backwards compatibility)
        :return: Entry object to be used with demisto.results()
        """
        if is_empty_object(obj):
            return CommandResults(readable_output="There is no output results")

        if filter_null_values:
            obj = filter_dict_null(obj)
        hr_obj = switch_hr_headers(obj, hr_header_changes)

        if isinstance(obj, list):
            if filter_null_values:
                obj = [filter_dict_null(k) for k in obj]
            hr_obj = [switch_hr_headers(k, hr_header_changes) for k in obj]

        if headers and isinstance(obj, dict):
            headers = list(set(headers).intersection(set(obj.keys())))

        return CommandResults(
            outputs=obj,
            outputs_prefix=context_key,
            readable_output=tableToMarkdown(title, hr_obj, headers),
        )


    def delete_attachments_for_message(
        client: EWSClient, item_id: str, target_mailbox: Optional[str] = None, attachment_ids=None
    ) -> list[CommandResults]:
        """
        Deletes attachments for a given message
        :param client: EWS Client
        :param item_id: item id
        :param (Optional) target_mailbox: target mailbox
        :param (Optional) attachment_ids: attachment ids to delete
        :return: entries that were deleted
        """
        attachment_ids = argToList(attachment_ids)
        attachments = client.get_attachments_for_item(item_id, target_mailbox, attachment_ids)
        deleted_file_attachments = []
        deleted_item_attachments = []
        for attachment in attachments:
            attachment_deleted_action = {
                ATTACHMENT_ID: attachment.attachment_id.id,
                ACTION: "deleted",
            }
            if isinstance(attachment, FileAttachment):
                deleted_file_attachments.append(attachment_deleted_action)
            else:
                deleted_item_attachments.append(attachment_deleted_action)

            attachment.detach()

        entries = []
        if len(deleted_file_attachments) > 0:
            entry = get_entry_for_object(
                "Deleted file attachments",
                "EWS.Items" + CONTEXT_UPDATE_FILE_ATTACHMENT,
                deleted_file_attachments,
                filter_null_values=(client.version != "O365"),
            )
            entries.append(entry)

        if len(deleted_item_attachments) > 0:
            entry = get_entry_for_object(
                "Deleted item attachments",
                "EWS.Items" + CONTEXT_UPDATE_ITEM_ATTACHMENT,
                deleted_item_attachments,
                filter_null_values=(client.version != "O365"),
            )
            entries.append(entry)

        return entries


    def get_searchable_mailboxes(client: EWSClient) -> CommandResults:
        """
        Retrieve searchable mailboxes command
        :param client: EWS Client
        :return: Context entry containing searchable mailboxes
        """
        searchable_mailboxes = GetSearchableMailboxes(protocol=client.get_protocol()).call()
        return get_entry_for_object(
            "Searchable mailboxes",
            "EWS.Mailboxes",
            searchable_mailboxes,
            ["displayName", "mailbox"],
            filter_null_values=(client.version != "O365"),
        )


    def move_item_between_mailboxes(
        src_client: EWSClient,
        item_id,
        destination_mailbox: str,
        destination_folder_path: str,
        dest_client: Optional[EWSClient] = None,
        source_mailbox: Optional[str] = None,
        is_public: Optional[bool] = None,
    ) -> CommandResults:
        """
        Moves item between mailboxes
        :param src_client: EWS Client for the source mailbox
        :param item_id: item id
        :param destination_mailbox: destination mailbox
        :param destination_folder_path: destination folder path
        :param (Optional) dest_client: EWS Client for the destination mailbox (For O365 since target mailbox impacts authentication)
        :param (Optional) source_mailbox: source mailbox (Defaults to account_email)
        :param (Optional) is_public: is the destination folder public
        :return: result object
        """
        if dest_client is None:
            dest_client = src_client

        source_account = src_client.get_account(source_mailbox)
        destination_account = dest_client.get_account(destination_mailbox)
        is_public = dest_client.is_default_folder(destination_folder_path, is_public)
        destination_folder = dest_client.get_folder_by_path(destination_folder_path, destination_account, is_public)

        item = src_client.get_item_from_mailbox(source_account, item_id)
        exported_items = source_account.export([item])
        destination_account.upload([(destination_folder, exported_items[0])])
        source_account.bulk_delete([item])

        move_result = {
            MOVED_TO_MAILBOX: destination_mailbox,
            MOVED_TO_FOLDER: destination_folder_path,
        }

        return CommandResults(
            outputs=move_result,
            outputs_prefix="EWS.Items",
            outputs_key_field="itemId",
            raw_response="Item was moved successfully.",
            readable_output=f"Item was moved successfully to mailbox: {destination_mailbox}, folder: {destination_folder_path}.",
        )


    def move_item(
        client: EWSClient,
        item_id: str,
        target_folder_path: str,
        target_mailbox: Optional[str] = None,
        is_public: Optional[bool] = None,
    ) -> CommandResults:
        """
        Moves an item within the same mailbox
        :param client: EWS Client
        :param item_id: item id
        :param target_folder_path: target folder path
        :param (Optional) target_mailbox: mailbox containing the item (defaults to account email)
        :param (Optional) is_public: is the destination folder public (default - False)
        :return: result object
        """
        account = client.get_account(target_mailbox)
        is_public = client.is_default_folder(target_folder_path, is_public)
        target_folder = client.get_folder_by_path(target_folder_path, is_public=is_public)
        item = client.get_item_from_mailbox(account, item_id)
        if isinstance(item, ErrorInvalidIdMalformed):
            raise Exception("Item not found")

        item.move(target_folder)
        move_result = {
            NEW_ITEM_ID: item.id,
            ITEM_ID: item_id,
            MESSAGE_ID: item.message_id,
            ACTION: "moved",
        }

        return get_entry_for_object(
            "Moved items", CONTEXT_UPDATE_EWS_ITEM, move_result, filter_null_values=(client.version != "O365")
        )


    def delete_items(client: EWSClient, item_ids, delete_type: str, target_mailbox: Optional[str] = None) -> CommandResults:
        """
        Delete items in a mailbox
        :param client: EWS Client
        :param item_ids: items ids to delete
        :param delete_type: delete type soft/hard
        :param (Optional) target_mailbox: mailbox containing the items (defaults to account email)
        :return: result object
        """
        deleted_items = []
        item_ids = argToList(item_ids)
        items = client.get_items_from_mailbox(target_mailbox, item_ids)
        delete_type = delete_type.lower()

        for item in items:
            item_id = item.id
            if delete_type == "trash":
                item.move_to_trash()
            elif delete_type == "soft":
                item.soft_delete()
            elif delete_type == "hard":
                item.delete()
            else:
                raise Exception(f'invalid delete type: {delete_type}. Use "trash" \\ "soft" \\ "hard"')

            deleted_items.append(
                {
                    ITEM_ID: item_id,
                    MESSAGE_ID: item.message_id,
                    ACTION: f"{delete_type}-deleted",
                }
            )

        return get_entry_for_object(
            f"Deleted items ({delete_type} delete type)",
            CONTEXT_UPDATE_EWS_ITEM,
            deleted_items,
            filter_null_values=(client.version != "O365"),
        )


    def get_out_of_office_state(client: EWSClient, target_mailbox: Optional[str] = None) -> CommandResults:
        """
        Retrieve get out of office state of the targeted mailbox
        :param client: EWS Client
        :param (Optional) target_mailbox: target mailbox
        :return: result object
        """
        account = client.get_account(target_mailbox)
        oof = account.oof_settings
        if not oof:
            raise DemistoException(f"Failed to get out of office state for {target_mailbox or client.account_email}")

        oof_dict = {
            "state": oof.state,
            "externalAudience": getattr(oof, "external_audience", None),
            "start": oof.start.ewsformat() if oof.start else None,
            "end": oof.end.ewsformat() if oof.end else None,
            "internalReply": getattr(oof, "internal_reply", None),
            "externalReply": getattr(oof, "external_reply", None),
            MAILBOX: account.primary_smtp_address,
        }

        return get_entry_for_object(
            f"Out of office state for {account.primary_smtp_address}",
            f"Account.Email(val.Address == obj.{MAILBOX}).OutOfOffice",
            oof_dict,
            filter_null_values=(client.version != "O365"),
        )


    def recover_soft_delete_item(
        client: EWSClient,
        message_ids,
        target_folder_path: str = "Inbox",
        target_mailbox: Optional[str] = None,
        is_public: Optional[bool] = None,
    ) -> CommandResults:
        """
        Recovers soft deleted items
        :param client: EWS Client
        :param message_ids: Message ids to recover
        :param (Optional) target_folder_path: target folder path
        :param (Optional) target_mailbox: target mailbox
        :param (Optional) is_public: is the target folder public
        :return: result object
        """
        account = client.get_account(target_mailbox)
        is_public = client.is_default_folder(target_folder_path, is_public)
        target_folder = client.get_folder_by_path(target_folder_path, account, is_public)
        recovered_messages = []
        message_ids = argToList(message_ids)

        items_to_recover = account.recoverable_items_deletions.filter(message_id__in=message_ids).all()

        recovered_items = set()
        for item in items_to_recover:
            recovered_items.add(item)

        if len(recovered_items) != len(message_ids):
            missing_items = set(message_ids).difference(recovered_items)
            raise Exception(f"Some message ids are missing in recoverable items directory: {missing_items}")

        for item in recovered_items:
            item.move(target_folder)
            recovered_messages.append({ITEM_ID: item.id, MESSAGE_ID: item.message_id, ACTION: "recovered"})

        return get_entry_for_object(
            "Recovered messages", CONTEXT_UPDATE_EWS_ITEM, recovered_messages, filter_null_values=(client.version != "O365")
        )


    def create_folder(client: EWSClient, new_folder_name: str, folder_path: str, target_mailbox: Optional[str] = None) -> str:
        """
        Creates a folder in the target mailbox or the client mailbox
        :param client: EWS Client
        :param new_folder_name: new folder name
        :param folder_path: path of the new folder
        :param (Optional) target_mailbox: target mailbox
        :return: Result message
        """
        account = client.get_account(target_mailbox)
        full_path = os.path.join(folder_path, new_folder_name)
        try:
            demisto.debug("Checking if folder exists")
            if client.get_folder_by_path(full_path, account):
                return f"Folder {full_path} already exists"
        except Exception:
            pass
        demisto.debug("Folder doesnt already exist. Getting path to add folder")
        parent_folder = client.get_folder_by_path(folder_path, account)

        demisto.debug("Saving folder")
        f = Folder(parent=parent_folder, name=new_folder_name)
        f.save()
        demisto.debug("Verifying folder was saved")
        client.get_folder_by_path(full_path, account)
        return f"Folder {full_path} created successfully"


    def mark_item_as_junk(client: EWSClient, item_id, move_items: str, target_mailbox: Optional[str] = None) -> CommandResults:
        """
        Marks item as junk in the target mailbox or client mailbox
        :param client: EWS Client
        :param item_id: item ids to mark as junk
        :param move_items: 'yes' or 'no' - to move or not to move to the junk folder
        :param (Optional) target_mailbox: target mailbox the item is in
        :return: Results object
        """
        account = client.get_account(target_mailbox)
        move_to_junk: bool = move_items.lower() == "yes"
        ews_result = MarkAsJunk(account=account).call(item_id=item_id, move_item=move_to_junk)
        mark_as_junk_result = {
            ITEM_ID: item_id,
        }
        if ews_result == "Success":
            mark_as_junk_result[ACTION] = "marked-as-junk"
        else:
            raise Exception(f"Failed mark-item-as-junk with error: {ews_result}")

        return get_entry_for_object(
            "Mark item as junk", CONTEXT_UPDATE_EWS_ITEM, mark_as_junk_result, filter_null_values=(client.version != "O365")
        )


    def folder_to_context_entry(f) -> dict:
        """
        Create a context entry from a folder response
        :param f: folder response
        :return: dict context entry
        """
        try:
            f_entry = {
                "name": f.name,
                "totalCount": f.total_count,
                "id": f.id,
                "childrenFolderCount": f.child_folder_count,
                "changeKey": f.changekey,
            }

            if "unread_count" in [x.name for x in Folder.FIELDS]:
                f_entry["unreadCount"] = f.unread_count
            return f_entry

        except AttributeError:
            if isinstance(f, dict):
                return {
                    "name": f.get("name"),
                    "totalCount": f.get("total_count"),
                    "id": f.get("id"),
                    "childrenFolderCount": f.get("child_folder_count"),
                    "changeKey": f.get("changekey"),
                    "unreadCount": f.get("unread_count"),
                }

        return {}


    def get_folder(
        client: EWSClient, folder_path: str, target_mailbox: Optional[str] = None, is_public: Optional[bool] = None
    ) -> CommandResults:
        """
        Retrieve a folder from the target mailbox or client mailbox
        :param client: EWS Client
        :param folder_path: folder path to retrieve
        :param (Optional) target_mailbox: target mailbox to get the folder from
        :param (Optional) is_public: is the folder public
        :return: Results object
        """
        account = client.get_account(target_mailbox)
        is_public = client.is_default_folder(folder_path, is_public)
        folder = folder_to_context_entry(client.get_folder_by_path(folder_path, account=account, is_public=is_public))

        return get_entry_for_object(
            f"Folder {folder_path}", CONTEXT_UPDATE_FOLDER, folder, filter_null_values=(client.version != "O365")
        )


    def get_expanded_group(client: EWSClient, email_address, recursive_expansion: bool = False) -> CommandResults:
        """
        Retrieve expanded group command
        :param client: EWS Client
        :param email_address: Email address of the group to expand
        :param (Optional) recursive_expansion: Whether to enable recursive expansion. Default is 'False'.
        :return: Results object containing expanded groups
        """
        group_members = ExpandGroup(protocol=client.get_protocol()).call(email_address, recursive_expansion)
        group_details = {"name": email_address, "members": group_members}
        entry_for_object = get_entry_for_object(
            "Expanded group", "EWS.ExpandGroup", group_details, filter_null_values=(client.version != "O365")
        )
        entry_for_object.readable_output = tableToMarkdown("Group Members", group_members)
        return entry_for_object


    def mark_item_as_read(
        client: EWSClient, item_ids, operation: str = "read", target_mailbox: Optional[str] = None
    ) -> CommandResults:
        """
        Marks item as read
        :param client: EWS Client
        :param item_ids: items ids to mark as read
        :param (Optional) operation: operation to execute
        :param (Optional) target_mailbox: target mailbox
        :return: results object
        """
        marked_items = []
        item_ids = argToList(item_ids)
        items = client.get_items_from_mailbox(target_mailbox, item_ids)
        items = [x for x in items if isinstance(x, Message)]

        for item in items:
            item.is_read = operation == "read"
            item.save()

            marked_items.append(
                {
                    ITEM_ID: item.id,
                    MESSAGE_ID: item.message_id,
                    ACTION: f"marked-as-{operation}",
                }
            )

        return get_entry_for_object(
            f"Marked items ({operation} marked operation)",
            CONTEXT_UPDATE_EWS_ITEM,
            marked_items,
            filter_null_values=(client.version != "O365"),
        )

    register_module_line('EWSApiModule', 'end', __line__(), wrapper=1)
    ### END GENERATED CODE ###
    from exchangelib import (
        BASIC,
        DELEGATE,
        DIGEST,
        IMPERSONATION,
        NTLM,
        Body,
        EWSDateTime,
        EWSTimeZone,
        FileAttachment,
        FolderCollection,
        HTMLBody,
        ItemAttachment,
        Version,
    )
    from exchangelib.errors import (
        ErrorCannotOpenFileAttachment,
        ErrorFolderNotFound,
        ErrorInvalidPropertyRequest,
        ErrorIrresolvableConflict,
        ErrorMailboxMoveInProgress,
        ErrorMailboxStoreUnavailable,
        ErrorMimeContentConversionFailed,
        ErrorNameResolutionNoResults,
        RateLimitError,
        TransportError,
    )
    from exchangelib.items import Contact, Item, Message
    from exchangelib.services import EWSService
    from exchangelib.util import add_xml_child, create_element
    from exchangelib.version import (
        EXCHANGE_2007,
        EXCHANGE_2010,
        EXCHANGE_2010_SP2,
        EXCHANGE_2013,
        EXCHANGE_2013_SP1,
        EXCHANGE_2016,
        EXCHANGE_2019,
    )
    from exchangelib.version import VERSIONS as EXC_VERSIONS
    from future import utils as future_utils
    from requests.exceptions import ConnectionError


    # Exchange2 2019 patch - server dosen't connect with 2019 but with other versions creating an error mismatch (see CIAC-3086),
    # overriding this function to remove minor version test and remove error throw.
    # opened bug for exchanglib here https://github.com/ecederstrand/exchangelib/issues/1210
    def our_fullname(self):  # pragma: no cover
        for build, api_version, full_name in EXC_VERSIONS:
            # removed 'or self.build.minor_version != build.minor_version'
            if self.build and self.build.major_version != build.major_version:
                continue
            if self.api_version == api_version:
                return full_name
        return None


    Version.fullname = our_fullname

    # Ignore warnings print to stdout
    warnings.filterwarnings("ignore")

    MNS, TNS = exchangelib.util.MNS, exchangelib.util.TNS

    # consts
    VERSIONS = {
        "2007": EXCHANGE_2007,
        "2010": EXCHANGE_2010,
        "2010_SP2": EXCHANGE_2010_SP2,
        "2013": EXCHANGE_2013,
        "2013_SP1": EXCHANGE_2013_SP1,
        "2016": EXCHANGE_2016,
        "2019": EXCHANGE_2019,
    }

    APP_NAME = "EWSv2"
    ATTACHMENT_ORIGINAL_ITEM_ID = "originalItemId"
    NEW_ITEM_ID = "newItemId"
    MESSAGE_ID = "messageId"
    ITEM_ID = "itemId"
    MAILBOX = "mailbox"
    MAILBOX_ID = "mailboxId"
    FOLDER_ID = "id"

    MOVED_TO_MAILBOX = "movedToMailbox"
    MOVED_TO_FOLDER = "movedToFolder"

    FILE_ATTACHMENT_TYPE = "FileAttachment"
    ITEM_ATTACHMENT_TYPE = "ItemAttachment"
    ATTACHMENT_TYPE = "attachmentType"

    TOIS_PATH = "/root/Top of Information Store/"

    ENTRY_CONTEXT = "EntryContext"
    CONTEXT_UPDATE_EWS_ITEM = (
        f"EWS.Items(val.{ITEM_ID} == obj.{ITEM_ID} || "
        f"(val.{MESSAGE_ID} && obj.{MESSAGE_ID} && val.{MESSAGE_ID} == obj.{MESSAGE_ID}))"
    )
    CONTEXT_UPDATE_EWS_ITEM_FOR_ATTACHMENT = f"EWS.Items(val.{ITEM_ID} == obj.{ATTACHMENT_ORIGINAL_ITEM_ID})"
    CONTEXT_UPDATE_FOLDER = f"EWS.Folders(val.{FOLDER_ID} == obj.{FOLDER_ID})"

    LAST_RUN_TIME = "lastRunTime"
    LAST_RUN_IDS = "ids"
    LAST_RUN_FOLDER = "folderName"
    ERROR_COUNTER = "errorCounter"

    ITEMS_RESULTS_HEADERS = [
        "sender",
        "subject",
        "hasAttachments",
        "datetimeReceived",
        "receivedBy",
        "author",
        "toRecipients",
        "textBody",
    ]


    LAST_RUN_IDS_QUEUE_SIZE = 500

    # NOTE: Same method used in EWSMailSender
    # If you are modifying this probably also need to modify in the other file


    def exchangelib_cleanup():  # pragma: no cover
        try:
            exchangelib.close_connections()
        except Exception as ex:
            demisto.error(f"Error was found in exchangelib cleanup, ignoring: {ex}")


    # Prep Functions
    def parse_auth_type(auth_type: str):  # pragma: no cover
        auth_type = auth_type.lower()
        if auth_type == "ntlm":
            return NTLM
        elif auth_type == "basic":
            return BASIC
        elif auth_type == "digest":
            return DIGEST
        raise Exception("{} auth method is not supported. Choose one of {}".format(auth_type, "ntlm\\basic\\digest"))


    # LOGGING
    log_stream = None
    log_handler = None


    def start_logging():
        global log_stream
        global log_handler
        logging.raiseExceptions = False
        if log_stream is None:
            log_stream = StringIO()
            log_handler = logging.StreamHandler(stream=log_stream)
            log_handler.setFormatter(logging.Formatter(logging.BASIC_FORMAT))
            logger = logging.getLogger()
            logger.addHandler(log_handler)
            logger.setLevel(logging.DEBUG)


    # Exchange 2010 Fixes
    def fix_2010(client: EWSClient):  # pragma: no cover
        version = client.server_build if client.server_build else get_on_prem_build(client.version)
        if version <= EXCHANGE_2010_SP2:
            for m in (
                Item,
                Message,
                exchangelib.items.CalendarItem,
                exchangelib.items.Contact,
                exchangelib.items.DistributionList,
                exchangelib.items.PostItem,
                exchangelib.items.Task,
                exchangelib.items.MeetingRequest,
                exchangelib.items.MeetingResponse,
                exchangelib.items.MeetingCancellation,
            ):
                for i, f in enumerate(m.FIELDS):
                    if f.name == "text_body":
                        m.FIELDS.pop(i)
                        break
            for m in (exchangelib.Folder, exchangelib.folders.Inbox):
                for i, f in enumerate(m.FIELDS):
                    if f.name == "unread_count":
                        m.FIELDS.pop(i)
                        break

            def repr1(self):
                return self.__class__.__name__ + repr(
                    (self.root, self.name, self.total_count, self.child_folder_count, self.folder_class, self.id, self.changekey)
                )

            def repr2(self):
                return self.__class__.__name__ + repr(
                    (self.root, self.name, self.total_count, self.child_folder_count, self.folder_class, self.changekey)
                )

            def repr3(self):
                return self.__class__.__name__ + repr(
                    (self.account, "[self]", self.name, self.total_count, self.child_folder_count, self.folder_class, self.changekey)
                )

            exchangelib.Folder.__repr__ = repr1
            exchangelib.folders.Inbox.__repr__ = exchangelib.folders.JunkEmail.__repr__ = repr2
            exchangelib.folders.Root.__repr__ = repr3

        start_logging()


    def str_to_unicode(obj):  # pragma: no cover
        if isinstance(obj, dict):
            obj = {k: str_to_unicode(v) for k, v in list(obj.items())}
        elif isinstance(obj, list):
            obj = [str_to_unicode(k) for k in obj]
        elif isinstance(obj, str):
            obj = obj.encode("utf-8")
        return obj


    def get_time_zone() -> EWSTimeZone | None:
        """get the XSOAR user time zone
        :return:
            returns an ``EWSTimeZone`` if TZ available or ``None`` if not
        :rtype: ``Optional[EWSTimeZone]``
        """
        time_zone = demisto.callingContext.get("context", {}).get("User", {}).get("timeZone", None)
        if time_zone:
            time_zone = EWSTimeZone(time_zone)
        return time_zone


    def get_attachment_name(attachment_name, content_id="", is_inline=False, attachment_subject=""):  # pragma: no cover
        demisto.debug(
            f"get_attachment_name called with attachment_name='{attachment_name}', content_id='{content_id}', "
            f"is_inline={is_inline}, attachment_subject='{attachment_subject}'"
        )

        legacy_name = argToBoolean(demisto.params().get("legacy_name", False))

        if is_inline and content_id and content_id != "None" and not legacy_name:
            if attachment_name is None or attachment_name == "":
                return f"{content_id}-attachmentName-demisto_untitled_attachment"
            return f"{content_id}-attachmentName-{attachment_name}"
        if not attachment_name and attachment_subject:
            return attachment_subject
        if not attachment_name and not attachment_subject:
            return "demisto_untitled_attachment"
        return attachment_name


    def send_email_to_mailbox(  # pragma: no cover
        account,
        to,
        subject,
        body,
        body_type,
        bcc,
        cc,
        reply_to,
        handle_inline_image: bool = True,
        html_body=None,
        attachments=None,
        raw_message=None,
        from_address=None,
    ):
        """
        Send an email to a mailbox.

        Args:
            body_type: type of the body. Can be 'html' or 'text' or None.
            account (Account): account from which to send an email.
            to (list[str]): a list of emails to send an email.
            subject (str): subject of the mail.
            body (str): body of the email.
            reply_to (list[str]): list of emails of which to reply to from the sent email.
            bcc (list[str]): list of email addresses for the 'bcc' field.
            cc (list[str]): list of email addresses for the 'cc' field.
            html_body (str): HTML formatted content (body) of the email to be sent. This argument
                overrides the "body" argument.
            attachments (list[str]): list of names of attachments to send.
            raw_message (str): Raw email message from MimeContent type.
            from_address (str): the email address from which to reply.
        """
        if not attachments:
            attachments = []
        message_body, inline_attachments = get_message_for_body_type(body, body_type, html_body, handle_inline_image)
        attachments += inline_attachments
        m = Message(
            account=account,
            mime_content=raw_message.encode("UTF-8") if raw_message else None,
            folder=account.sent,
            cc_recipients=cc,
            bcc_recipients=bcc,
            subject=subject,
            body=message_body,
            to_recipients=to,
            reply_to=reply_to,
            author=from_address,
        )
        if account.protocol.version.build <= EXCHANGE_2010_SP2:
            m.save()
            for attachment in attachments:
                m.attach(attachment)
            m.send()
        else:
            for attachment in attachments:
                m.attach(attachment)
            m.send_and_save()
        return m


    def get_message_for_body_type(body, body_type, html_body, handle_inline_image: bool):
        """
        Compatibility with Data Collection - where body_type is not provided, we will use the html_body if it exists.
        Compatibility with 'send-mail' command - where body_type should be provided, we will use the body_type to decide.
        Args:
            body_type: type of the body. Can be 'html' or 'text' or None.
            body: plain text body.
            html_body: HTML formatted content (body) of the email to be sent.

        Returns:
            Body: the body of the message.
        """
        demisto.debug(f"get_message_for_body_type: Received {body_type=}, {handle_inline_image=}")
        attachments: list = []

        if html_body and handle_inline_image:
            html_body, attachments = handle_html(html_body)
            demisto.debug(f"get_message_for_body_type: Processed HTML body with {len(attachments)} attachments")

        if body_type is None:  # When called from a data collection task.
            return (HTMLBody(html_body) if html_body else Body(body)), attachments

        if body_type.lower() == "html" and html_body:  # When called from 'send-mail' command.
            return HTMLBody(html_body), attachments

        return Body(body) if (body or not html_body) else HTMLBody(html_body), attachments


    class SearchMailboxes(EWSService):
        def __init__(self, protocol, limit):
            self.limit = limit
            super().__init__(protocol)

        SERVICE_NAME = "SearchMailboxes"
        element_container_name = f"{{{MNS}}}SearchMailboxesResult/{{{TNS}}}Items"

        @staticmethod
        def parse_element(element):  # pragma: no cover
            to_recipients = element.find(f"{{{TNS}}}ToRecipients")
            if to_recipients:
                to_recipients = [x.text if x is not None else None for x in to_recipients]

            result = {
                ITEM_ID: element.find(f"{{{TNS}}}Id").attrib["Id"] if element.find(f"{{{TNS}}}Id") is not None else None,
                MAILBOX: element.find(f"{{{TNS}}}Mailbox/{{{TNS}}}PrimarySmtpAddress").text
                if element.find(f"{{{TNS}}}Mailbox/{{{TNS}}}PrimarySmtpAddress") is not None
                else None,
                "subject": element.find(f"{{{TNS}}}Subject").text if element.find(f"{{{TNS}}}Subject") is not None else None,
                "toRecipients": to_recipients,
                "sender": element.find(f"{{{TNS}}}Sender").text if element.find(f"{{{TNS}}}Sender") is not None else None,
                "hasAttachments": element.find(f"{{{TNS}}}HasAttachment").text
                if element.find(f"{{{TNS}}}HasAttachment") is not None
                else None,
                "datetimeSent": element.find(f"{{{TNS}}}SentTime").text if element.find(f"{{{TNS}}}SentTime") is not None else None,
                "datetimeReceived": element.find(f"{{{TNS}}}ReceivedTime").text
                if element.find(f"{{{TNS}}}ReceivedTime") is not None
                else None,
            }

            return result

        def call(self, query, mailboxes):  # pragma: no cover
            if self.protocol.version.build < EXCHANGE_2013:
                raise NotImplementedError(f"{self.SERVICE_NAME} is only supported for Exchange 2013 servers and later")
            elements = list(self._get_elements(payload=self.get_payload(query, mailboxes)))
            return [self.parse_element(x) for x in elements]

        def get_payload(self, query, mailboxes):  # pragma: no cover
            def get_mailbox_search_scope(mailbox_id):
                mailbox_search_scope = create_element("t:MailboxSearchScope")
                add_xml_child(mailbox_search_scope, "t:Mailbox", mailbox_id)
                add_xml_child(mailbox_search_scope, "t:SearchScope", "All")
                return mailbox_search_scope

            mailbox_query_element = create_element("t:MailboxQuery")
            add_xml_child(mailbox_query_element, "t:Query", query)
            mailboxes_scopes = []
            for mailbox in mailboxes:
                mailboxes_scopes.append(get_mailbox_search_scope(mailbox))
            add_xml_child(mailbox_query_element, "t:MailboxSearchScopes", mailboxes_scopes)

            element = create_element(f"m:{self.SERVICE_NAME}")
            add_xml_child(element, "m:SearchQueries", mailbox_query_element)
            add_xml_child(element, "m:ResultType", "PreviewOnly")
            add_xml_child(element, "m:PageSize", str(self.limit))

            return element


    def search_mailboxes(client: EWSClient, filter, limit=100, mailbox_search_scope=None, email_addresses=None):  # pragma: no cover
        """
        Search mailboxes for items matching the given filter.

        Args:
            client (EWSClient): The EWS client object.
            filter (str): The search filter to apply.
            limit (int): The maximum number of results to return. Default value is 100.
            mailbox_search_scope (str or list, optional): The mailbox search scope. Defaults to None.
            email_addresses (str, optional): Comma-separated list of email addresses to search. Defaults to None.

        Returns:
            dict: A dictionary containing the search results.

        Raises:
            Exception: If both mailbox_search_scope and email_addresses are provided, or if no searchable mailboxes are found.
        """
        mailbox_ids = []
        limit_argument = arg_to_number(limit)
        if not limit_argument:
            raise DemistoException(f"Invalid limit value: {limit}. Please provide a valid integer.")

        if mailbox_search_scope is not None and email_addresses is not None:
            raise Exception("Use one of the arguments - mailbox-search-scope or email-addresses, not both")
        if email_addresses:
            email_addresses = email_addresses.split(",")
            all_mailboxes = GetSearchableMailboxes(protocol=client.get_protocol()).call()
            for email_address in email_addresses:
                for mailbox in all_mailboxes:
                    addr = mailbox.get(MAILBOX, None)
                    if addr and email_address.lower() == addr.lower():
                        mailbox_ids.append(mailbox[MAILBOX_ID])
            if len(mailbox_ids) == 0:
                raise Exception("No searchable mailboxes were found for the provided email addresses.")
        elif mailbox_search_scope:
            mailbox_ids = mailbox_search_scope if type(mailbox_search_scope) is list else [mailbox_search_scope]
        else:
            all_mailboxes = GetSearchableMailboxes(protocol=client.get_protocol()).call()
            mailbox_ids = [x[MAILBOX_ID] for x in all_mailboxes if x.get(MAILBOX_ID, None)]
        try:
            search_results = SearchMailboxes(protocol=client.get_protocol(), limit=limit_argument).call(filter, mailbox_ids)
        except TransportError as e:
            if "ItemCount>0<" in str(e):
                return "No results for search query: " + filter
            else:
                raise e

        return get_entry_for_object("Search mailboxes results", CONTEXT_UPDATE_EWS_ITEM, search_results)


    def get_last_run(client: EWSClient):
        last_run = demisto.getLastRun()
        if not last_run or last_run.get(LAST_RUN_FOLDER) != client.folder_name:
            last_run = {LAST_RUN_TIME: None, LAST_RUN_FOLDER: client.folder_name, LAST_RUN_IDS: []}
        if LAST_RUN_TIME in last_run and last_run[LAST_RUN_TIME] is not None:
            last_run[LAST_RUN_TIME] = EWSDateTime.from_string(last_run[LAST_RUN_TIME])

        # In case we have existing last_run data
        if last_run.get(LAST_RUN_IDS) is None:
            last_run[LAST_RUN_IDS] = []

        return last_run


    def fetch_last_emails(
        client: EWSClient,
        folder_name="Inbox",
        since_datetime=None,
        exclude_ids=None,
        fetch_all_history=False,
        fetch_time="10 minutes",
    ):
        account = client.get_account(client.account_email)
        qs = client.get_folder_by_path(folder_name, account, is_public=client.is_public_folder)
        demisto.debug(f"since_datetime: {since_datetime}")
        if since_datetime:
            qs = qs.filter(datetime_received__gte=since_datetime)
        else:
            if not fetch_all_history:
                tz = EWSTimeZone("UTC")
                first_fetch_datetime = dateparser.parse(fetch_time)
                if not first_fetch_datetime:
                    raise DemistoException("Failed to parse first last run time")
                first_fetch_ews_datetime = first_fetch_datetime.astimezone(tz)
                qs = qs.filter(datetime_received__gte=first_fetch_ews_datetime)
        qs = qs.filter().only(*[x.name for x in Message.FIELDS])
        qs = qs.filter().order_by("datetime_received")
        result = []
        exclude_ids = exclude_ids if exclude_ids else set()
        demisto.debug(f"Exclude ID list: {exclude_ids}")

        for item in qs:
            try:
                demisto.debug(
                    f"Looking on subject={item.subject}, "
                    f"message_id={item.message_id}, "
                    f"created={item.datetime_created}, "
                    f"received={item.datetime_received}"
                )
                if isinstance(item, Message) and item.message_id not in exclude_ids:
                    result.append(item)
                    demisto.debug(f"Appending {item.subject}, {item.message_id}.")
                    if len(result) >= client.max_fetch:
                        break
            except ValueError as exc:
                future_utils.raise_from(
                    ValueError("Got an error when pulling incidents. You might be using the wrong exchange version."), exc
                )
                raise exc
            except ErrorMimeContentConversionFailed as exc:
                demisto.debug(f"Encountered an ErrorMimeContentConversionFailed error object while iterating: {exc}.\
                    Continuing to next item.")
                continue
            except AttributeError as exc:
                demisto.debug(f"Encountered an Attribute error object while iterating: {exc}.\
                     Continuing to next item.")

        demisto.debug(f"EWS V2 - Got total of {len(result)} from ews query. ")
        return result


    def keys_to_camel_case(value):
        def str_to_camel_case(snake_str):
            # Add condition as Email object arrived in list and raised error
            if not isinstance(snake_str, str):
                return snake_str
            components = snake_str.split("_")
            return components[0] + "".join(x.title() for x in components[1:])

        if value is None:
            return None
        if isinstance(value, list | set):
            return [keys_to_camel_case(v) for v in value]
        if isinstance(value, dict):
            return {
                keys_to_camel_case(k): keys_to_camel_case(v) if isinstance(v, list | dict) else v for (k, v) in list(value.items())
            }

        return str_to_camel_case(value)


    def email_ec(item):  # pragma: no cover
        return {
            "CC": None if not item.cc_recipients else [mailbox.email_address for mailbox in item.cc_recipients],
            "BCC": None if not item.bcc_recipients else [mailbox.email_address for mailbox in item.bcc_recipients],
            "To": None if not item.to_recipients else [mailbox.email_address for mailbox in item.to_recipients],
            "From": item.author.email_address,
            "Subject": item.subject,
            "Text": item.text_body,
            "HTML": item.body,
            "HeadersMap": {} if not item.headers else {header.name: header.value for header in item.headers},
        }


    def parse_object_as_dict_with_serialized_items(object):
        raw_dict = {}
        if object is not None:
            for field in object.FIELDS:
                try:
                    v = getattr(object, field.name, None)
                    if v is not None:
                        json.dumps(v)
                        raw_dict[field.name] = v
                except (TypeError, OverflowError):
                    demisto.debug(f"Data in field {field.name} is not serilizable, skipped field value is \n{v}\n")
                    continue
        return raw_dict


    def parse_item_as_dict(item, email_address=None, camel_case=False, compact_fields=False):  # pragma: no cover
        def parse_object_as_dict(object):
            raw_dict = {}
            if object is not None:
                for field in object.FIELDS:
                    field_val = getattr(object, field.name, None)
                    try:
                        json.dumps(field_val)
                    except TypeError:
                        field_val = parse_object_as_dict(field_val)
                    raw_dict[field.name] = field_val
            return raw_dict

        def parse_folder_as_json(folder):  # pragma: no cover
            raw_dict = parse_object_as_dict(folder)
            if "parent_folder_id" in raw_dict:
                raw_dict["parent_folder_id"] = parse_folder_as_json(raw_dict["parent_folder_id"])
            if "effective_rights" in raw_dict:
                raw_dict["effective_rights"] = parse_object_as_dict(raw_dict["effective_rights"])
            return raw_dict

        raw_dict = parse_object_as_dict_with_serialized_items(item)

        if getattr(item, "attachments", None):
            raw_dict["attachments"] = [parse_attachment_as_dict(item.id, x) for x in item.attachments]

        for time_field in ["datetime_sent", "datetime_created", "datetime_received", "last_modified_time", "reminder_due_by"]:
            value = getattr(item, time_field, None)
            if value:
                raw_dict[time_field] = value.ewsformat()

        for dict_field in [
            "effective_rights",
            "parent_folder_id",
            "conversation_id",
            "author",
            "extern_id",
            "received_by",
            "received_representing",
            "reply_to",
            "sender",
            "folder",
        ]:
            value = getattr(item, dict_field, None)
            if value:
                if type(value) is list:
                    raw_dict[dict_field] = [parse_object_as_dict(x) for x in value]
                else:
                    raw_dict[dict_field] = parse_object_as_dict(value)

        for list_dict_field in ["headers", "cc_recipients", "to_recipients"]:
            value = getattr(item, list_dict_field, None)
            if value:
                raw_dict[list_dict_field] = [parse_object_as_dict(x) for x in value]

        for list_str_field in ["categories"]:
            value = getattr(item, list_str_field, None)
            if value:
                raw_dict[list_str_field] = value

        if getattr(item, "folder", None):
            raw_dict["folder"] = parse_folder_as_json(item.folder)
            folder_path = (
                item.folder.absolute[len(TOIS_PATH) :] if item.folder.absolute.startswith(TOIS_PATH) else item.folder.absolute
            )
            raw_dict["folder_path"] = folder_path

        raw_dict["item_id"] = getattr(item, "id", None)
        raw_dict["id"] = getattr(item, "id", None)

        if compact_fields:
            new_dict = {}
            fields_list = [
                "datetime_created",
                "datetime_received",
                "datetime_sent",
                "sender",
                "has_attachments",
                "importance",
                "message_id",
                "last_modified_time",
                "size",
                "subject",
                "text_body",
                "headers",
                "body",
                "folder_path",
                "is_read",
                "categories",
            ]

            fields_list.append("item_id")

            for field in fields_list:
                if field in raw_dict:
                    new_dict[field] = raw_dict.get(field)
            for field in ["received_by", "author", "sender"]:
                if field in raw_dict:
                    new_dict[field] = raw_dict.get(field, {}).get("email_address")
            for field in ["to_recipients"]:
                if field in raw_dict:
                    new_dict[field] = [x.get("email_address") for x in raw_dict[field]]
            attachments = raw_dict.get("attachments")
            if attachments and len(attachments) > 0:
                file_attachments = [x for x in attachments if x[ATTACHMENT_TYPE] == FILE_ATTACHMENT_TYPE]
                if len(file_attachments) > 0:
                    new_dict["FileAttachments"] = file_attachments
                item_attachments = [x for x in attachments if x[ATTACHMENT_TYPE] == ITEM_ATTACHMENT_TYPE]
                if len(item_attachments) > 0:
                    new_dict["ItemAttachments"] = item_attachments
            raw_dict = new_dict

        if camel_case:
            raw_dict = keys_to_camel_case(raw_dict)

        if email_address:
            raw_dict[MAILBOX] = email_address
        return raw_dict


    def cast_mime_item_to_message(item):
        mime_content = item.mime_content
        email_policy = SMTP if mime_content.isascii() else SMTPUTF8
        if isinstance(mime_content, bytes):
            return email.message_from_bytes(mime_content, policy=email_policy)  # type: ignore[arg-type]
        else:
            return email.message_from_string(mime_content, policy=email_policy)  # type: ignore[arg-type]


    def parse_incident_from_item(item, is_fetch, mark_as_read):  # pragma: no cover
        incident = {}
        labels = []

        try:
            try:
                incident["details"] = item.text_body or item.body
            except AttributeError:
                incident["details"] = item.body

            incident["name"] = item.subject
            labels.append({"type": "Email/subject", "value": item.subject})
            incident["occurred"] = item.datetime_created.ewsformat()

            # handle recipients
            if item.to_recipients:
                for recipient in item.to_recipients:
                    labels.append({"type": "Email", "value": recipient.email_address})

            # handle cc
            if item.cc_recipients:
                for recipient in item.cc_recipients:
                    labels.append({"type": "Email/cc", "value": recipient.email_address})
            # handle email from
            if item.sender:
                labels.append({"type": "Email/from", "value": item.sender.email_address})

            # email format
            email_format = ""
            try:
                if item.text_body:
                    labels.append({"type": "Email/text", "value": item.text_body})
                    email_format = "text"
            except AttributeError:
                pass
            if item.body:
                labels.append({"type": "Email/html", "value": item.body})
                email_format = "HTML"
            labels.append({"type": "Email/format", "value": email_format})

            # handle attachments
            if item.attachments:
                incident["attachment"] = []
                for attachment in item.attachments:
                    if attachment is not None:
                        attachment.parent_item = item
                        file_result = None
                        label_attachment_type = None
                        label_attachment_id_type = None
                        if isinstance(attachment, FileAttachment):
                            try:
                                if attachment.content:
                                    # file attachment
                                    label_attachment_type = "attachments"
                                    label_attachment_id_type = "attachmentId"

                                    # save the attachment
                                    file_name = get_attachment_name(
                                        attachment_name=attachment.name,
                                        content_id=attachment.content_id,
                                        is_inline=attachment.is_inline,
                                    )
                                    file_result = fileResult(file_name, attachment.content)

                                    # check for error
                                    if file_result["Type"] == entryTypes["error"]:
                                        demisto.error(file_result["Contents"])
                                        raise Exception(file_result["Contents"])

                                    # save attachment to incident
                                    incident["attachment"].append(
                                        {
                                            "path": file_result["FileID"],
                                            "name": get_attachment_name(
                                                attachment_name=attachment.name,
                                                content_id=attachment.content_id,
                                                is_inline=attachment.is_inline,
                                            ),
                                            "description": FileAttachmentType.ATTACHED if not attachment.is_inline else "",
                                        }
                                    )
                            except TypeError as e:
                                if str(e) != "must be string or buffer, not None":
                                    raise
                                continue
                            except ErrorCannotOpenFileAttachment as e:
                                if str(e) != "The attachment could not be opened.":
                                    raise
                                demisto.error(f"Skipped attachment: {attachment.name} - {e}")
                                continue
                        else:
                            # other item attachment
                            label_attachment_type = "attachmentItems"
                            label_attachment_id_type = "attachmentItemsId"
                            formatted_message: str | bytes
                            # save the attachment
                            if hasattr(attachment, "item") and attachment.item.mime_content:
                                # Some items arrive with bytes attachemnt
                                attached_email = cast_mime_item_to_message(attachment.item)
                                if attachment.item.headers:
                                    attached_email_headers = []
                                    for h, v in list(attached_email.items()):
                                        if not isinstance(v, str):
                                            try:
                                                v = str(v)
                                            except:  # noqa: E722
                                                demisto.debug(f'cannot parse the header "{h}"')
                                                continue

                                        v = " ".join(map(str.strip, v.split("\r\n")))
                                        attached_email_headers.append((h.lower(), v))

                                    for header in attachment.item.headers:
                                        if (
                                            header.name.lower(),
                                            header.value,
                                        ) not in attached_email_headers and header.name.lower() != "content-type":
                                            try:
                                                attached_email.add_header(header.name, header.value)
                                            except ValueError as err:
                                                if "There may be at most" not in str(err):
                                                    raise err
                                try:
                                    formatted_message = attached_email.as_string()
                                except UnicodeEncodeError:
                                    formatted_message = attached_email.as_bytes()
                                file_result = fileResult(
                                    get_attachment_name(
                                        attachment_name=attachment.name,
                                        content_id=attachment.content_id,
                                        is_inline=attachment.is_inline,
                                        attachment_subject=attachment.item.subject,
                                    )
                                    + ".eml",
                                    formatted_message,
                                )

                            if file_result:
                                # check for error
                                if file_result["Type"] == entryTypes["error"]:
                                    demisto.error(file_result["Contents"])
                                    raise Exception(file_result["Contents"])

                                # save attachment to incident
                                incident["attachment"].append(
                                    {
                                        "path": file_result["FileID"],
                                        "name": get_attachment_name(
                                            attachment_name=attachment.name,
                                            content_id=attachment.content_id,
                                            is_inline=attachment.is_inline,
                                            attachment_subject=attachment.item.subject,
                                        )
                                        + ".eml",
                                    }
                                )

                            else:
                                incident["attachment"].append(
                                    {
                                        "name": get_attachment_name(
                                            attachment_name=attachment.name,
                                            content_id=attachment.content_id,
                                            is_inline=attachment.is_inline,
                                            attachment_subject=attachment.item.subject,
                                        )
                                        + ".eml",
                                    }
                                )

                        labels.append(
                            {
                                "type": label_attachment_type,
                                "value": get_attachment_name(
                                    attachment_name=attachment.name,
                                    content_id=attachment.content_id,
                                    is_inline=attachment.is_inline,
                                    attachment_subject="" if isinstance(attachment, FileAttachment) else attachment.item.subject,
                                ),
                            }
                        )

                        labels.append({"type": label_attachment_id_type, "value": attachment.attachment_id.id})

            # handle headers
            if item.headers:
                headers = []
                for header in item.headers:
                    labels.append({"type": f"Email/Header/{header.name}", "value": str(header.value)})
                    headers.append(f"{header.name}: {header.value}")
                labels.append({"type": "Email/headers", "value": "\r\n".join(headers)})

            # handle item id
            if item.message_id:
                labels.append({"type": "Email/MessageId", "value": str(item.message_id)})
                # fetch history
                incident["dbotMirrorId"] = str(item.message_id)

            if item.id:
                labels.append({"type": "Email/ID", "value": item.id})
                labels.append({"type": "Email/itemId", "value": item.id})

            # handle conversion id
            if item.conversation_id:
                labels.append({"type": "Email/ConversionID", "value": item.conversation_id.id})

            if mark_as_read and is_fetch:
                item.is_read = True
                try:
                    item.save()
                except ErrorIrresolvableConflict:
                    time.sleep(0.5)
                    item.save()
                except ValueError as e:
                    if item.subject and len(item.subject) > 255:
                        demisto.debug(
                            "Length of message subject is greater than 255, item.save could not handle it, cutting the subject."
                        )
                        sub_subject = f"Length of subject greater than 255 characters. Partial subject: {item.subject[:180]}"
                        item.subject = sub_subject
                        item.save()
                    else:
                        raise e

            incident["labels"] = labels
            incident["rawJSON"] = json.dumps(parse_item_as_dict(item, None), ensure_ascii=False)

        except Exception as e:
            if "Message is not decoded yet" in str(e):
                demisto.debug("EWS v2 - Skipped a protected message")
                return None
            else:
                raise e

        return incident


    def fetch_emails_as_incidents(
        client: EWSClient, skip_unparsable_emails: bool = False, fetch_all_history=False, fetch_time="10 minutes"
    ) -> list[dict]:
        last_run = get_last_run(client)
        excluded_ids = set(last_run.get(LAST_RUN_IDS, []))

        try:
            last_emails = fetch_last_emails(
                client, client.folder_name, last_run.get(LAST_RUN_TIME), excluded_ids, fetch_all_history, fetch_time
            )

            incidents = []
            incident = {}  # type: Dict[Any, Any]
            current_fetch_ids = set()
            last_incident_run_time = None

            for item in last_emails:
                try:
                    if item.message_id:
                        current_fetch_ids.add(item.message_id)
                        incident = parse_incident_from_item(item, True, client.mark_as_read)
                        demisto.debug(f"Parsed incident: {item.message_id}")
                        if incident:
                            incidents.append(incident)
                            last_incident_run_time = item.datetime_received
                            demisto.debug(f"Appended incident: {item.message_id}")

                        if len(incidents) >= client.max_fetch:
                            break
                except Exception as e:
                    if not skip_unparsable_emails:  # default is to raise and exception and fail the command
                        raise

                    # when the skip param is `True`, we log the exceptions and move on instead of failing the whole fetch
                    error_msg = (
                        "Encountered email parsing issue while fetching. "
                        f"Skipping item with message id: {item.message_id or '<error parsing message_id>'}"
                    )
                    demisto.debug(f"{error_msg}, Error: {e!s} {traceback.format_exc()}")
                    demisto.updateModuleHealth(error_msg, is_error=False)

            demisto.debug(f"EWS V2 - ending fetch - got {len(incidents)} incidents.")
            last_fetch_time = last_run.get(LAST_RUN_TIME)
            last_incident_run_time = last_incident_run_time if last_incident_run_time else last_fetch_time

            # making sure both last fetch time and the time of last incident are the same type for comparing.
            if isinstance(last_incident_run_time, EWSDateTime):
                last_incident_run_time = last_incident_run_time.ewsformat()

            if isinstance(last_fetch_time, EWSDateTime):
                last_fetch_time = last_fetch_time.ewsformat()

            debug_msg = "#### last_incident_time: {}({}). last_fetch_time: {}({}) ####"
            demisto.debug(
                debug_msg.format(last_incident_run_time, type(last_incident_run_time), last_fetch_time, type(last_fetch_time))
            )

            # If the fetch query is not fully fetched (we didn't have any time progress) - then we keep the
            # id's from current fetch until progress is made. This is for when max_fetch < incidents_from_query.
            if not last_incident_run_time or not last_fetch_time or last_incident_run_time > last_fetch_time:
                ids = current_fetch_ids
            else:
                ids = current_fetch_ids | excluded_ids
            new_last_run = {
                LAST_RUN_TIME: last_incident_run_time,
                LAST_RUN_FOLDER: client.folder_name,
                LAST_RUN_IDS: list(ids),
                ERROR_COUNTER: 0,
            }

            demisto.setLastRun(new_last_run)
            return incidents

        except RateLimitError:
            if LAST_RUN_TIME in last_run:
                last_run[LAST_RUN_TIME] = last_run[LAST_RUN_TIME].ewsformat()
            if ERROR_COUNTER not in last_run:
                last_run[ERROR_COUNTER] = 0
            last_run[ERROR_COUNTER] += 1
            demisto.setLastRun(last_run)
            if last_run[ERROR_COUNTER] > 2:
                raise
            return []


    def get_entry_for_file_attachment(item_id, attachment):  # pragma: no cover
        entry = fileResult(
            get_attachment_name(attachment_name=attachment.name, content_id=attachment.content_id, is_inline=attachment.is_inline),
            attachment.content,
        )
        ec = {CONTEXT_UPDATE_EWS_ITEM_FOR_ATTACHMENT + CONTEXT_UPDATE_FILE_ATTACHMENT: parse_attachment_as_dict(item_id, attachment)}
        entry[ENTRY_CONTEXT] = filter_dict_null(ec)
        return entry


    def parse_attachment_as_dict(item_id, attachment):  # pragma: no cover
        try:
            # if this is a file attachment or a non-empty email attachment
            if isinstance(attachment, FileAttachment) or hasattr(attachment, "item"):
                attachment_content = attachment.content if isinstance(attachment, FileAttachment) else attachment.item.mime_content

                return {
                    ATTACHMENT_ORIGINAL_ITEM_ID: item_id,
                    ATTACHMENT_ID: attachment.attachment_id.id,
                    "attachmentName": get_attachment_name(
                        attachment_name=attachment.name,
                        content_id=attachment.content_id,
                        is_inline=attachment.is_inline,
                        attachment_subject="" if isinstance(attachment, FileAttachment) else attachment.item.subject,
                    ),
                    "attachmentSHA256": hashlib.sha256(attachment_content).hexdigest() if attachment_content else None,
                    "attachmentContentType": attachment.content_type,
                    "attachmentContentId": attachment.content_id,
                    "attachmentContentLocation": attachment.content_location,
                    "attachmentSize": attachment.size,
                    "attachmentLastModifiedTime": attachment.last_modified_time.ewsformat(),
                    "attachmentIsInline": attachment.is_inline,
                    ATTACHMENT_TYPE: FILE_ATTACHMENT_TYPE if isinstance(attachment, FileAttachment) else ITEM_ATTACHMENT_TYPE,
                }

            # If this is an empty email attachment
            else:
                return {
                    ATTACHMENT_ORIGINAL_ITEM_ID: item_id,
                    ATTACHMENT_ID: attachment.attachment_id.id,
                    "attachmentName": get_attachment_name(
                        attachment_name=attachment.name,
                        content_id=attachment.content_id,
                        is_inline=attachment.is_inline,
                        attachment_subject="" if isinstance(attachment, FileAttachment) else attachment.item.subject,
                    ),
                    "attachmentSize": attachment.size,
                    "attachmentLastModifiedTime": attachment.last_modified_time.ewsformat(),
                    "attachmentIsInline": attachment.is_inline,
                    ATTACHMENT_TYPE: FILE_ATTACHMENT_TYPE if isinstance(attachment, FileAttachment) else ITEM_ATTACHMENT_TYPE,
                }

        except (TypeError, ErrorCannotOpenFileAttachment) as e:
            if str(e) not in ("must be string or buffer, not None", "The attachment could not be opened."):
                raise
            demisto.debug(f"Add attachment info to context, without the content. Error: {e!s}")
            return {
                ATTACHMENT_ORIGINAL_ITEM_ID: item_id,
                ATTACHMENT_ID: attachment.attachment_id.id,
                "attachmentName": get_attachment_name(
                    attachment_name=attachment.name,
                    content_id=attachment.content_id,
                    is_inline=attachment.is_inline,
                    attachment_subject="" if isinstance(attachment, FileAttachment) else attachment.item.subject,
                ),
                "attachmentSHA256": None,
                "attachmentContentType": attachment.content_type,
                "attachmentContentId": attachment.content_id,
                "attachmentContentLocation": attachment.content_location,
                "attachmentSize": attachment.size,
                "attachmentLastModifiedTime": attachment.last_modified_time.ewsformat(),
                "attachmentIsInline": attachment.is_inline,
                ATTACHMENT_TYPE: FILE_ATTACHMENT_TYPE if isinstance(attachment, FileAttachment) else ITEM_ATTACHMENT_TYPE,
            }


    def get_entry_for_item_attachment(item_id, attachment, target_email):  # pragma: no cover
        item = attachment.item
        dict_result = parse_attachment_as_dict(item_id, attachment)
        dict_result.update(parse_item_as_dict(item, target_email, camel_case=True, compact_fields=True))
        title = f'EWS get attachment got item for "{target_email}", "{get_attachment_name(attachment_name=attachment.name, content_id=attachment.content_id, is_inline=attachment.is_inline, attachment_subject=attachment.item.subject)}"'  # noqa: E501

        return get_entry_for_object(title, CONTEXT_UPDATE_EWS_ITEM_FOR_ATTACHMENT + CONTEXT_UPDATE_ITEM_ATTACHMENT, dict_result)


    def fetch_attachments_for_message(
        client: EWSClient, item_id: str, target_mailbox: Optional[str] = None, attachment_ids=[], identifiers_filter=""
    ) -> list:  # pragma: no cover
        identifiers_filter = argToList(identifiers_filter)
        account = client.get_account(target_mailbox or client.account_email)
        attachment_ids = argToList(attachment_ids)
        attachments = client.get_attachments_for_item(item_id, account, attachment_ids)
        entries = []
        for attachment in attachments:
            if isinstance(attachment, FileAttachment):
                try:
                    if attachment.content:
                        entries.append(get_entry_for_file_attachment(item_id, attachment))
                except (TypeError, ErrorCannotOpenFileAttachment) as e:
                    if str(e) not in ("must be string or buffer, not None", "The attachment could not be opened."):
                        raise
                    demisto.debug(f"Skipping attachment '{attachment.name}', Error: {e}")
            else:
                entries.append(get_entry_for_item_attachment(item_id, attachment, account.primary_smtp_address))
                if attachment.item.mime_content:
                    attached_email = cast_mime_item_to_message(attachment.item)
                    entries.append(
                        fileResult(
                            get_attachment_name(
                                attachment.name,
                                content_id=attachment.content_id,
                                is_inline=attachment.is_inline,
                                attachment_subject=attachment.item.subject,
                            )
                            + ".eml",
                            attached_email.as_string(),
                        )
                    )

        return entries


    def prepare_args(d):  # pragma: no cover
        d = {k.replace("-", "_"): v for k, v in list(d.items())}
        if "is_public" in d:
            d["is_public"] = d["is_public"] == "True"
        return d


    def get_limited_number_of_messages_from_qs(qs, limit):  # pragma: no cover
        count = 0
        results = []
        for item in qs:
            if count == limit:
                break
            if isinstance(item, Message):
                count += 1
                results.append(item)
        return results


    def search_items_in_mailbox(
        client: EWSClient,
        query=None,
        message_id=None,
        folder_path="",
        limit=100,
        target_mailbox=None,
        is_public=None,
        selected_fields="all",
        surround_id_with_angle_brackets=True,
    ):  # pragma: no cover
        if not query and not message_id:
            return_error("Missing required argument. Provide query or message-id")
        if argToBoolean(surround_id_with_angle_brackets) and message_id and message_id[0] != "<" and message_id[-1] != ">":
            message_id = f"<{message_id}>"
        account = client.get_account(target_mailbox or client.account_email)
        limit = int(limit)
        if folder_path.lower() == "inbox":
            folders = [account.inbox]
        elif folder_path:
            is_public = client.is_default_folder(folder_path, is_public)
            folders = [client.get_folder_by_path(folder_path, account, is_public)]
        else:
            folders = FolderCollection(account=account, folders=[account.root.tois]).find_folders()  # pylint: disable=E1101
        items = []  # type: ignore
        selected_all_fields = selected_fields == "all"
        if selected_all_fields:
            restricted_fields = {x.name for x in Message.FIELDS}  # type: ignore
        else:
            restricted_fields = set(argToList(selected_fields))  # type: ignore
            restricted_fields.update(["id", "message_id"])  # type: ignore

        for folder in folders:
            if Message not in folder.supported_item_models:
                continue
            if query:
                items_qs = folder.filter(query).only(*restricted_fields)
            else:
                items_qs = folder.filter(message_id=message_id).only(*restricted_fields)
            items += get_limited_number_of_messages_from_qs(items_qs, limit)
            if len(items) >= limit:
                break
        items = items[:limit]
        searched_items_result = [
            parse_item_as_dict(item, account.primary_smtp_address, camel_case=True, compact_fields=selected_all_fields)
            for item in items
        ]
        if not selected_all_fields:
            # we show id as 'itemId' for BC
            restricted_fields.remove("id")
            restricted_fields.add("itemId")
            searched_items_result = [
                {k: v for (k, v) in i.items() if k in keys_to_camel_case(restricted_fields)} for i in searched_items_result
            ]
        return get_entry_for_object(
            "Searched items",
            CONTEXT_UPDATE_EWS_ITEM,
            searched_items_result,
            headers=ITEMS_RESULTS_HEADERS if selected_all_fields else None,
        )


    def parse_physical_address(address):
        result = {}
        for attr in ["city", "country", "label", "state", "street", "zipcode"]:
            result[attr] = getattr(address, attr, None)
        return result


    def parse_phone_number(phone_number):
        result = {attr: getattr(phone_number, attr, None) for attr in ["label", "phone_number"]}
        return result if result.get("phone_number") else {}


    def is_jsonable(x):
        try:
            json.dumps(x)
            return True
        except Exception:
            return False


    def parse_contact(contact):
        contact_dict = parse_object_as_dict_with_serialized_items(contact)
        for k in contact_dict:
            v = contact_dict[k]
            if isinstance(v, EWSDateTime):
                contact_dict[k] = v.ewsformat()  # pylint: disable=E4702

        contact_dict["id"] = contact.id
        if isinstance(contact, Contact) and contact.physical_addresses:
            contact_dict["physical_addresses"] = list(map(parse_physical_address, contact.physical_addresses))
        if isinstance(contact, Contact) and contact.phone_numbers:
            contact_dict["phone_numbers"] = [elt for elt in map(parse_phone_number, contact.phone_numbers) if elt]
        if isinstance(contact, Contact) and contact.email_addresses and len(contact.email_addresses) > 0:
            contact_dict["emailAddresses"] = [x.email for x in contact.email_addresses]
        contact_dict = keys_to_camel_case(contact_dict)
        contact_dict = {k: v for k, v in contact_dict.items() if (v and is_jsonable(v))}
        return contact_dict


    def get_contacts(client: EWSClient, limit, target_mailbox=None):  # pragma: no cover
        account = client.get_account(target_mailbox or client.account_email)
        contacts = []

        for contact in account.contacts.all()[: int(limit)]:  # pylint: disable=E1101
            contact = parse_contact(contact)
            contact["originMailbox"] = target_mailbox
            contacts.append(contact)
        return get_entry_for_object(
            f"Email contacts for {target_mailbox or client.account_email}",
            "Account.Email(val.Address == obj.originMailbox).EwsContacts",
            contacts,
        )


    def find_folders(client: EWSClient, target_mailbox=None, is_public=None):  # pragma: no cover
        account = client.get_account(target_mailbox or client.account_email)
        root = account.public_folders_root if is_public else account.root.tois  # pylint: disable=E1101
        root_collection = FolderCollection(account=account, folders=[root])
        folders = []
        for f in root_collection.find_folders():  # pylint: disable=E1101
            folder = folder_to_context_entry(f)
            folders.append(folder)

        readable_output = root.tree()  # pylint: disable=E1101

        return {
            "Type": entryTypes["note"],
            "Contents": folders,
            "ContentsFormat": formats["json"],
            "ReadableContentsFormat": formats["markdown"],
            "HumanReadable": readable_output,
            ENTRY_CONTEXT: {"EWS.Folders(val.id == obj.id)": folders},
        }


    def get_items_from_folder(
        client: EWSClient, folder_path, limit=100, target_mailbox=None, is_public=None, get_internal_item="no"
    ):  # pragma: no cover
        account = client.get_account(target_mailbox or client.account_email)
        limit = int(limit)
        get_internal_item = get_internal_item == "yes"
        is_public = client.is_default_folder(folder_path, is_public)
        folder = client.get_folder_by_path(folder_path, account, is_public)
        qs = folder.filter().order_by("-datetime_created")[:limit]
        items = get_limited_number_of_messages_from_qs(qs, limit)
        items_result = []

        for item in items:
            item_attachment = parse_item_as_dict(item, account.primary_smtp_address, camel_case=True, compact_fields=True)

            for attachment in item.attachments:
                if attachment is not None:
                    attachment.parent_item = item
                    if get_internal_item and isinstance(attachment, ItemAttachment) and isinstance(attachment.item, Message):
                        # if found item attachment - switch item to the attchment
                        item_attachment = parse_item_as_dict(
                            attachment.item, account.primary_smtp_address, camel_case=True, compact_fields=True
                        )
                        break

            items_result.append(item_attachment)
        hm_headers = ["sender", "subject", "hasAttachments", "datetimeReceived", "receivedBy", "author", "toRecipients", "itemId"]
        return get_entry_for_object("Items in folder " + folder_path, CONTEXT_UPDATE_EWS_ITEM, items_result, headers=hm_headers)


    def get_items(client: EWSClient, item_ids, target_mailbox=None):  # pragma: no cover
        account = client.get_account(target_mailbox or client.account_email)
        item_ids = argToList(item_ids)

        items = client.get_items_from_mailbox(account, item_ids)
        items = [x for x in items if isinstance(x, Message)]
        items_as_incidents = [parse_incident_from_item(x, False, client.mark_as_read) for x in items]
        items_to_context = [parse_item_as_dict(x, account.primary_smtp_address, True, True) for x in items]

        return {
            "Type": entryTypes["note"],
            "Contents": items_as_incidents,
            "ContentsFormat": formats["json"],
            "ReadableContentsFormat": formats["markdown"],
            "HumanReadable": tableToMarkdown("Get items", items_to_context, ITEMS_RESULTS_HEADERS),
            ENTRY_CONTEXT: {
                CONTEXT_UPDATE_EWS_ITEM: items_to_context,
                "Email": [email_ec(item) for item in items],
            },
        }


    def get_autodiscovery_config():  # pragma: no cover
        config_dict = demisto.getIntegrationContext()
        return {
            "Type": entryTypes["note"],
            "Contents": config_dict,
            "ContentsFormat": formats["json"],
            "ReadableContentsFormat": formats["markdown"],
            "HumanReadable": tableToMarkdown("Auto-Discovery Exchange Configuration", config_dict),
        }


    def format_identifier(identifier):
        """
        Exchangelib has a default smtp routing type. If there's no given routingtype, add explicitly so that
        exchangelib can be searched by secondary email addresses without making cusomter add it manually
        """
        return f"smtp:{identifier}" if "@" in identifier and ":" not in identifier else identifier


    def resolve_name_command(client: EWSClient, args):  # pragma: no cover
        protocol = client.get_protocol()
        unresolved_entry = format_identifier(args["identifier"])
        full_contact_data = argToBoolean(args.get("full_contact_data", True))
        resolved_names = protocol.resolve_names([unresolved_entry], return_full_contact_data=full_contact_data, search_scope="")
        demisto.debug(f"{len(resolved_names)=}")

        output = []
        for rn in resolved_names:
            if isinstance(rn, ErrorNameResolutionNoResults):
                demisto.info(f"got ErrorNameResolutionNoResults error, {rn!s}")
                return "No results were found."
            elif isinstance(rn, tuple):
                mail, contact = rn
            else:
                mail, contact = rn, None
            mail_context = parse_item_as_dict(mail)
            if contact:
                mail_context["FullContactInfo"] = parse_contact(contact)
            output.append(mail_context)
        return get_entry_for_object(
            "Resolved Names",
            "EWS.ResolvedNames(val.email_address && val.email_address == obj.email_address)",
            remove_empty_elements(output),  # noqa: F405
            headers=["primary_email_address", "name", "mailbox_type", "routing_type"],
            hr_header_changes={"email_address": "primary_email_address"},
        )


    def get_item_as_eml(client: EWSClient, item_id, target_mailbox=None):  # pragma: no cover
        account = client.get_account(target_mailbox or client.account_email)
        item = client.get_item_from_mailbox(account, item_id)

        if item.mime_content:
            # came across an item with bytes attachemnt which failed in the source code, added this to keep functionality
            email_content = cast_mime_item_to_message(item)
            if item.headers:
                attached_email_headers = []
                for h, v in list(email_content.items()):
                    if not isinstance(v, str):
                        try:
                            v = str(v)
                        except:  # noqa: E722
                            demisto.debug(f'cannot parse the header "{h}"')

                    v = " ".join(map(str.strip, v.split("\r\n")))
                    attached_email_headers.append((h.lower(), v))
                for header in item.headers:
                    if (header.name.lower(), header.value) not in attached_email_headers and header.name.lower() != "content-type":
                        try:
                            email_content.add_header(header.name, header.value)
                        except ValueError as err:
                            if "There may be at most" not in str(err):
                                raise err
            eml_name = item.subject if item.subject else "demisto_untitled_eml"
            file_result = fileResult(eml_name + ".eml", email_content.as_string())
            file_result = file_result if file_result else "Failed uploading eml file to war room"

            return file_result
        return None


    def collect_manual_attachments(manual_attach_obj):  # pragma: no cover
        attachments = []
        for attachment in manual_attach_obj:
            res = demisto.getFilePath(os.path.basename(attachment["RealFileName"]))

            file_path = res["path"]
            with open(file_path, "rb") as f:
                attachments.append(FileAttachment(content=f.read(), name=attachment["FileName"]))

        return attachments


    def process_attachments(attach_cids="", attach_ids="", attach_names="", manual_attach_obj=None):  # pragma: no cover
        if manual_attach_obj is None:
            manual_attach_obj = []
        file_entries_for_attachments = []  # type: list
        attachments_names = []  # type: list

        if attach_ids:
            file_entries_for_attachments = attach_ids if isinstance(attach_ids, list) else attach_ids.split(",")
            if attach_names:
                attachments_names = attach_names if isinstance(attach_names, list) else attach_names.split(",")
            else:
                for att_id in file_entries_for_attachments:
                    att_name = demisto.getFilePath(att_id)["name"]
                    if isinstance(att_name, list):
                        att_name = att_name[0]
                    attachments_names.append(att_name)
            if len(file_entries_for_attachments) != len(attachments_names):
                raise Exception("attachIDs and attachNames lists should be the same length")

        attachments = collect_manual_attachments(manual_attach_obj)

        if attach_cids:
            file_entries_for_attachments_inline = attach_cids if isinstance(attach_cids, list) else attach_cids.split(",")
            for att_id_inline in file_entries_for_attachments_inline:
                try:
                    file_info = demisto.getFilePath(att_id_inline)
                except Exception as ex:
                    demisto.info(f"EWS error from getFilePath: {ex}")
                    raise Exception(f"entry {att_id_inline} does not contain a file")
                att_name_inline = file_info["name"]
                with open(file_info["path"], "rb") as f:
                    attachments.append(
                        FileAttachment(content=f.read(), name=att_name_inline, is_inline=True, content_id=att_name_inline)
                    )

        for i in range(len(file_entries_for_attachments)):
            entry_id = file_entries_for_attachments[i]
            attachment_name = attachments_names[i]
            try:
                res = demisto.getFilePath(entry_id)
            except Exception as ex:
                raise Exception(f"entry {entry_id} does not contain a file: {ex!s}")
            file_path = res["path"]
            with open(file_path, "rb") as f:
                attachments.append(FileAttachment(content=f.read(), name=attachment_name))
        return attachments, attachments_names


    def get_none_empty_addresses(addresses_ls):
        return [adress for adress in addresses_ls if adress]


    def send_email(client: EWSClient, args):
        time_zone = get_time_zone()
        account = client.get_account(target_mailbox=client.account_email, time_zone=time_zone)
        bcc = get_none_empty_addresses(argToList(args.get("bcc")))
        cc = get_none_empty_addresses(argToList(args.get("cc")))
        to = get_none_empty_addresses(argToList(args.get("to")))
        replyTo = get_none_empty_addresses(argToList(args.get("replyTo")))
        render_body = argToBoolean(args.get("renderBody") or False)
        handle_inline_image: bool = argToBoolean(args.get("handle_inline_image", True))
        subject = args.get("subject")
        subject = subject[:252] + "..." if len(subject) > 255 else subject

        attachments, attachments_names = process_attachments(
            args.get("attachCIDs", ""), args.get("attachIDs", ""), args.get("attachNames", ""), args.get("manualAttachObj") or []
        )

        body_type = args.get("bodyType", args.get("body_type"))
        send_email_to_mailbox(
            account=account,
            to=to,
            subject=subject,
            body=args.get("body"),
            body_type=body_type,
            bcc=bcc,
            cc=cc,
            reply_to=replyTo,
            handle_inline_image=handle_inline_image,
            html_body=args.get("htmlBody"),
            attachments=attachments,
            raw_message=args.get("raw_message"),
            from_address=args.get("from"),
        )
        result_object = {
            "from": args.get("from") or account.primary_smtp_address,
            "to": to,
            "subject": subject,
            "attachments": attachments_names,
        }

        results = [
            {
                "Type": entryTypes["note"],
                "Contents": result_object,
                "ContentsFormat": formats["json"],
                "ReadableContentsFormat": formats["markdown"],
                "HumanReadable": tableToMarkdown("Sent email", result_object),
            }
        ]
        if render_body:
            results.append({"Type": entryTypes["note"], "ContentsFormat": formats["html"], "Contents": args.get("htmlBody")})
        return results


    def reply_email(client: EWSClient, args: dict):  # pragma: no cover
        time_zone = get_time_zone()
        account = client.get_account(target_mailbox=client.account_email, time_zone=time_zone)
        bcc = argToList(args.get("bcc"))
        cc = argToList(args.get("cc"))
        to = argToList(args.get("to"))
        handle_inline_image: bool = argToBoolean(args.get("handle_inline_image", True))
        from_mailbox = args.get("from")
        subject = args.get("subject", "")
        subject = subject[:252] + "..." if subject and len(subject) > 255 else subject

        attachments, attachments_names = process_attachments(
            args.get("attachCIDs", ""), args.get("attachIDs", ""), args.get("attachNames", ""), args.get("manualAttachObj") or []
        )

        client.reply_email(
            in_reply_to=args.get("inReplyTo", ""),
            to=to,
            body=args.get("body", ""),
            subject=subject,
            bcc=bcc,
            cc=cc,
            html_body=args.get("htmlBody"),
            attachments=attachments,
            from_mailbox=from_mailbox,
            account=account,
            handle_inline_image=handle_inline_image,
        )
        result_object = {
            "from": from_mailbox or account.primary_smtp_address,
            "to": to,
            "subject": subject,
            "attachments": attachments_names,
        }

        return {
            "Type": entryTypes["note"],
            "Contents": result_object,
            "ContentsFormat": formats["json"],
            "ReadableContentsFormat": formats["markdown"],
            "HumanReadable": tableToMarkdown("Sent email", result_object),
        }


    def test_module(client: EWSClient):  # pragma: no cover
        try:
            account = client.get_account(client.account_email)
            folder = client.get_folder_by_path(client.folder_name, account, client.is_public_folder)
            if not folder.effective_rights.read:  # pylint: disable=E1101
                raise Exception(
                    "Success to authenticate, but user has no permissions to read from the mailbox. "
                    "Need to delegate the user permissions to the mailbox - "
                    "please read integration documentation and follow the instructions"
                )
            folder.test_access()
        except ErrorFolderNotFound as e:
            if "Top of Information Store" in str(e):
                raise Exception(
                    "Success to authenticate, but user probably has no permissions to read from the specific folder."
                    "Check user permissions. You can try !ews-find-folders command to "
                    "get all the folders structure that the user has permissions to"
                )

        demisto.results("ok")


    def get_client_from_params(params: dict):
        """
        Constructs an EWSClient instance from the provided integration parameters.

        :param params: The dictionary received from demisto.params()

        :return: An EWSClient instance for interacting with the Exchange server.
        """
        username = params.get("credentials", {}).get("identifier")
        password = params.get("credentials", {}).get("password")
        access_type = IMPERSONATION if params.get("impersonation", False) else DELEGATE
        account_email = params.get("defaultTargetMailbox", "")
        max_fetch = min(50, int(params.get("maxFetch", 50)))
        ews_server = params.get("ewsServer", "")
        auth_type = params.get("authType", "")
        if auth_type:
            auth_type = parse_auth_type(auth_type)
        version = params.get("defaultServerVersion", "")
        folder = params.get("folder", "Inbox")
        is_public_folder = params.get("isPublicFolder", False)
        request_timeout = int(params.get("requestTimeout", 120))
        mark_as_read = params.get("markAsRead", False)
        manual_username = params.get("domainAndUserman", "")
        insecure = params.get("insecure", True)

        if ews_server and manual_username:
            username = manual_username

        return EWSClient(
            client_id=username,
            client_secret=password,
            access_type=access_type,
            default_target_mailbox=account_email,
            max_fetch=max_fetch,
            ews_server=ews_server,
            auth_type=auth_type,
            version=version,
            folder=folder,
            is_public_folder=is_public_folder,
            request_timeout=request_timeout,
            mark_as_read=mark_as_read,
            incident_filter=IncidentFilter.RECEIVED_FILTER,
            app_name=APP_NAME,
            insecure=insecure,
        )


    def sub_main():  # pragma: no cover
        params = demisto.params()

        args = prepare_args(demisto.args())
        client = get_client_from_params(params)
        skip_unparsable_emails: bool = argToBoolean(params.get("skip_unparsable_emails", False))
        fetch_all_history = argToBoolean(demisto.params().get("fetchAllHistory", False))
        fetch_time = demisto.params().get("fetch_time") or "10 minutes"
        is_test_module = False

        fix_2010(client)

        try:
            if demisto.command() == "test-module":
                is_test_module = True
                test_module(client)
            elif demisto.command() == "fetch-incidents":
                incidents = fetch_emails_as_incidents(client, skip_unparsable_emails, fetch_all_history, fetch_time)
                demisto.incidents(incidents)
            elif demisto.command() == "ews-get-attachment":
                return_results(fetch_attachments_for_message(client, **args))
            elif demisto.command() == "ews-delete-attachment":
                return_results(delete_attachments_for_message(client, **args))
            elif demisto.command() == "ews-get-searchable-mailboxes":
                return_results(get_searchable_mailboxes(client))
            elif demisto.command() == "ews-search-mailboxes":
                return_results(search_mailboxes(client, **args))
            elif demisto.command() == "ews-move-item-between-mailboxes":
                return_results(move_item_between_mailboxes(client, **args))
            elif demisto.command() == "ews-move-item":
                return_results(move_item(client, **args))
            elif demisto.command() == "ews-delete-items":
                return_results(delete_items(client, **args))
            elif demisto.command() == "ews-search-mailbox":
                return_results(search_items_in_mailbox(client, **args))
            elif demisto.command() == "ews-get-contacts":
                return_results(get_contacts(client, **args))
            elif demisto.command() == "ews-get-out-of-office":
                return_results(get_out_of_office_state(client, **args))
            elif demisto.command() == "ews-recover-messages":
                return_results(recover_soft_delete_item(client, **args))
            elif demisto.command() == "ews-create-folder":
                return_results(create_folder(client, **args))
            elif demisto.command() == "ews-mark-item-as-junk":
                return_results(mark_item_as_junk(client, **args))
            elif demisto.command() == "ews-find-folders":
                return_results(find_folders(client, **args))
            elif demisto.command() == "ews-get-items-from-folder":
                return_results(get_items_from_folder(client, **args))
            elif demisto.command() == "ews-get-items":
                return_results(get_items(client, **args))
            elif demisto.command() == "ews-get-folder":
                return_results(get_folder(client, **args))
            elif demisto.command() == "ews-get-autodiscovery-config":
                return_results(get_autodiscovery_config())
            elif demisto.command() == "ews-expand-group":
                return_results(get_expanded_group(client, **args))
            elif demisto.command() == "ews-mark-items-as-read":
                return_results(mark_item_as_read(client, **args))
            elif demisto.command() == "ews-resolve-name":
                return_results(resolve_name_command(client, args))
            elif demisto.command() == "ews-get-items-as-eml":
                return_results(get_item_as_eml(client, **args))
            elif demisto.command() == "send-mail":
                return_results(send_email(client, args))
            elif demisto.command() == "reply-mail":
                return_results(reply_email(client, args))
            else:
                return_error(f'Command: "{demisto.command()}" was not recognized by this integration')

        except Exception as e:
            import time

            time.sleep(2)
            start_logging()
            debug_log = log_stream.getvalue()  # type: ignore
            error_message_simple = ""
            error_message = ""

            # Office365 regular maintenance case
            if (
                isinstance(e, ErrorMailboxMoveInProgress | ErrorMailboxStoreUnavailable)
                and urlparse(client.ews_server.lower()).hostname == "outlook.office365.com"
            ):
                log_message = (
                    "Office365 is undergoing load balancing operations. As a result, the service is temporarily unavailable."
                )
                if demisto.command() == "fetch-incidents":
                    demisto.info(log_message)
                    demisto.incidents([])
                    sys.exit(0)
                if is_test_module:
                    demisto.results(log_message + " Please retry the instance configuration test.")
                    sys.exit(0)
                error_message_simple = log_message + " Please retry your request."

            if isinstance(e, ConnectionError):
                error_message_simple = (
                    "Could not connect to the server.\n"
                    "Verify that the Hostname or IP address is correct.\n\n"
                    f"Additional information: {e!s}"
                )
            if isinstance(e, ErrorInvalidPropertyRequest):
                error_message_simple = "Verify that the Exchange version is correct."
            else:
                from exchangelib.errors import MalformedResponseError

                if is_test_module and isinstance(e, MalformedResponseError):
                    error_message_simple = (
                        "Got invalid response from the server.\nVerify that the Hostname or IP address is is correct."
                    )

            # Legacy error handling
            if "Status code: 401" in debug_log:
                error_message_simple = (
                    "Got unauthorized from the server. Check credentials are correct and authentication method are supported. "
                )

                error_message_simple += (
                    "You can try using 'domain\\username' as username for authentication. "
                    if client.auth_type.lower() == "ntlm"
                    else ""
                )

            if "SSL: CERTIFICATE_VERIFY_FAILED" in debug_log:
                # same status code (503) but different error.
                error_message_simple = (
                    "Certificate verification failed - This error may happen if the server "
                    "certificate cannot be validated or as a result of a proxy that is doing SSL/TLS "
                    "termination. It is possible to bypass certificate validation by checking "
                    "'Trust any certificate' in the instance settings."
                )

            elif "Status code: 503" in debug_log:
                error_message_simple = (
                    "Got timeout from the server. "
                    "Probably the server is not reachable with the current settings. "
                    "Check proxy parameter. If you are using server URL - change to server IP address. "
                )

            if not error_message_simple:
                error_message = error_message_simple = str(e)
            else:
                error_message = error_message_simple + "\n" + str(e)

            stacktrace = traceback.format_exc()
            if stacktrace:
                error_message += "\nFull stacktrace:\n" + stacktrace

            if debug_log:
                error_message += "\nFull debug log:\n" + debug_log

            if demisto.command() == "fetch-incidents":
                raise Exception(str(e) + traceback.format_exc())
            if demisto.command() == "ews-search-mailbox" and isinstance(e, ValueError):
                return_error(message="Selected invalid field, please specify valid field name.", error=e)
            if is_test_module:
                demisto.results(error_message_simple)
            else:
                demisto.results({"Type": entryTypes["error"], "ContentsFormat": formats["text"], "Contents": error_message_simple})
            demisto.error(f"{e.__class__.__name__}: {error_message}")
        finally:
            exchangelib_cleanup()
            if log_stream:
                try:
                    logging.getLogger().removeHandler(log_handler)  # type: ignore
                    log_stream.close()
                except Exception as ex:
                    demisto.error(f"EWS: unexpected exception when trying to remove log handler: {ex}")


    def process_main():  # pragma: no cover
        """setup stdin to fd=0 so we can read from the server"""
        sys.stdin = os.fdopen(0, "r")
        sub_main()


    def main():  # pragma: no cover
        try:
            handle_proxy()
            # When running big queries, like 'ews-search-mailbox' the memory might not freed by the garbage
            # collector. `separate_process` flag will run the integration on a separate process that will prevent
            # memory leakage.
            separate_process = demisto.params().get("separate_process", False)
            demisto.debug(f"Running as separate_process: {separate_process}")
            if separate_process:
                try:
                    p = Process(target=process_main)
                    p.start()
                    p.join()
                except Exception as ex:
                    demisto.error(f"Failed starting Process: {ex}")
            else:
                sub_main()
        except Exception as exc:
            return_error(f"Found error in EWSv2: {exc}", error=f"Error: {exc}\nTraceback: {traceback.format_exc()}")


    # python2 uses __builtin__ python3 uses builtins
    if __name__ in ("__builtin__", "builtins", "__main__"):  # pragma: no cover
        main()

    register_module_line('EWS v2', 'end', __line__())
  subtype: python3
  type: python
sectionorder:
- Connect
- Collect
system: true
